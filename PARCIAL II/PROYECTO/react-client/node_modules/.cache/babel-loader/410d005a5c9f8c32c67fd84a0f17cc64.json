{"ast":null,"code":"// import React, { useEffect, useState } from 'react';\n// import { over } from 'stompjs';\n// import SockJS from 'sockjs-client';\n// import ChatRoomUI from './ChatRoomUI';\n// import axios from 'axios';\n// import DOMPurify from 'dompurify';\n// let stompClient = null;\n// const ChatRoom = () => {\n//   const [privateChats, setPrivateChats] = useState(new Map());\n//   const [publicChats, setPublicChats] = useState([]);\n//   const [tab, setTab] = useState(\"CHATROOM\");\n//   const [unreadMessages, setUnreadMessages] = useState(new Map());\n//   const [allUsers, setAllUsers] = useState([]);\n//   const [searchQuery, setSearchQuery] = useState('');\n//   const [userData, setUserData] = useState({\n//     username: '',\n//     password: '',\n//     email: '',\n//     receivername: '',\n//     connected: false,\n//     message: '',\n//     errors: {}\n//   });\n//   const [isRegistering, setIsRegistering] = useState(false);\n//   useEffect(() => {\n//     if (userData.connected) {\n//       connect();\n//       fetchAllUsers();\n//       loadChatHistory();\n//     }\n//   }, [userData.connected]);\n//   useEffect(() => {\n//     if (tab !== \"CHATROOM\" && userData.connected) {\n//       loadPrivateChatHistory(tab);\n//     }\n//   }, [tab]);\n//   /*\n//   const loadPrivateChatHistory = async (receiverName) => {\n//     try {\n//       const response = await axios.get(`http://localhost:8080/api/chats/history?senderName=${userData.username}&receiverName=${receiverName}`);\n//       setPrivateChats(new Map(privateChats.set(receiverName, response.data)));\n//     } catch (error) {\n//       console.error('Error loading private chat history:', error);\n//     }\n//   };*/\n//   const loadPrivateChatHistory = async (receiverName) => {\n//     try {\n//         const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=${receiverName}`);\n//         const sortedMessages = response.data.sort((a, b) => new Date(a.date) - new Date(b.date));\n//         setPrivateChats(new Map(privateChats.set(receiverName, sortedMessages)));\n//     } catch (error) {\n//         console.error('Error loading private chat history:', error);\n//     }\n//   };\n//   const connect = () => {\n//     let Sock = new SockJS('http://localhost:8080/ws');\n//     stompClient = over(Sock);\n//     stompClient.connect({username: userData.username}, onConnected, onError);\n//   }\n//   const onConnected = () => {\n//     setUserData({ ...userData, connected: true });\n//     stompClient.subscribe('/chatroom/public', onMessageReceived);\n//     stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\n//     userJoin();\n//     fetchAllUsers();\n//     loadChatHistory();\n//   }\n//   const userJoin = () => {\n//     var chatMessage = {\n//       senderName: userData.username,\n//       status: \"JOIN\"\n//     };\n//     stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\n//   }\n//   const fetchAllUsers = async () => {\n//     try {\n//       const response = await axios.get('http://localhost:8080/api/users/all');\n//       setAllUsers(response.data);\n//     } catch (error) {\n//       console.error('Failed to fetch users:', error);\n//     }\n//   };\n//   const sendPrivateValue = () => {\n//     if (stompClient) {\n//         var chatMessage = {\n//             senderName: userData.username,\n//             receiverName: tab,\n//             message: userData.message,\n//             status: \"MESSAGE\"\n//         };\n//         if (userData.username !== tab) {\n//             let msgs = privateChats.get(tab) || [];\n//             msgs.push(chatMessage);\n//             setPrivateChats(new Map(privateChats.set(tab, msgs)));\n//         }\n//         stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\n//         setUserData({ ...userData, message: \"\" });\n//     }\n// }\n// /*\n// const sendPrivateValue = () => {\n//   if (stompClient) {\n//       var chatMessage = {\n//           senderName: userData.username,\n//           receiverName: tab,\n//           message: userData.message,\n//           status: \"MESSAGE\"\n//       };\n//       if (userData.username !== tab) {\n//           let msgs = privateChats.get(tab) || [];\n//           msgs.push(chatMessage);\n//           setPrivateChats(new Map(privateChats.set(tab, msgs)));\n//       }\n//       stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\n//       setUserData({ ...userData, message: \"\" });\n//   }\n// }*/\n// const searchUsers = async () => {\n//     try {\n//         const response = await axios.get(`http://localhost:8080/api/users/search`, {\n//             params: { query: searchQuery }\n//         });\n//         setAllUsers(response.data);\n//     } catch (error) {\n//         console.error('Error searching users:', error);\n//     }\n// };\n// /*\n//   const loadChatHistory = async () => {\n//     try {\n//         const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=ALL`);\n//         setPublicChats(response.data);\n//     } catch (error) {\n//         console.error('Error loading chat history:', error);\n//     }\n// };*/\n// /*\n// const loadChatHistory = async () => {\n//   try {\n//       // Obtener mensajes públicos\n//       const publicResponse = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=ALL`);\n//       setPublicChats(publicResponse.data);\n//       // Obtener mensajes privados\n//       const privateResponse = await axios.get(`http://localhost:8080/api/chats/history?senderName=${userData.username}&receiverName=${userData.username}`);\n//       privateResponse.data.forEach(chat => {\n//           let messages = privateChats.get(chat.receiverName) || [];\n//           messages.push(chat);\n//           setPrivateChats(new Map(privateChats.set(chat.receiverName, messages)));\n//       });\n//   } catch (error) {\n//       console.error('Error loading chat history:', error);\n//   }\n// };*/\n// const loadChatHistory = async () => {\n//   try {\n//       const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=ALL`);\n//       const sortedMessages = response.data.sort((a, b) => new Date(a.date) - new Date(b.date));\n//       setPublicChats(sortedMessages);\n//   } catch (error) {\n//       console.error('Error loading chat history:', error);\n//   }\n// };\n// // In the useEffect hook\n// useEffect(() => {\n//   if (userData.connected) {\n//       connect();\n//       fetchAllUsers();\n//       loadChatHistory();\n//   }\n// }, [userData.connected]);\n// useEffect(() => {\n//   if (tab !== \"CHATROOM\" && userData.connected) {\n//       loadPrivateChatHistory(tab);\n//   }\n// }, [tab]);\n// /*\n//   const onMessageReceived = (payload) => {\n//     var payloadData = JSON.parse(payload.body);\n//     switch (payloadData.status) {\n//       case \"JOIN\":\n//         if (!privateChats.get(payloadData.senderName)) {\n//           privateChats.set(payloadData.senderName, []);\n//           setPrivateChats(new Map(privateChats));\n//         }\n//         break;\n//       case \"MESSAGE\":\n//         publicChats.push(payloadData);\n//         setPublicChats([...publicChats]);\n//         break;\n//     }\n//   }\n//   */\n//     const onMessageReceived = (payload) => {\n//       var payloadData = JSON.parse(payload.body);\n//       switch (payloadData.status) {\n//           case \"JOIN\":\n//               if (!privateChats.get(payloadData.senderName)) {\n//                   privateChats.set(payloadData.senderName, []);\n//                   setPrivateChats(new Map(privateChats));\n//               }\n//               fetchAllUsers();\n//               break;\n//           case \"MESSAGE\":\n//               publicChats.push(payloadData);\n//               setPublicChats([...publicChats]);\n//               break;\n//           case \"NEW_USER\":\n//             fetchAllUsers(); // Actualizar la lista de usuarios cuando un nuevo usuario se registra\n//             break;\n//           default:\n//               setAllUsers([...allUsers, payloadData]);\n//               break;\n//       }\n//   }\n//   const sanitizeInput = (input) => {\n//     return DOMPurify.sanitize(input);\n//   };\n// /*\n//   const onPrivateMessage = (payload) => {\n//     var payloadData = JSON.parse(payload.body);\n//     if (privateChats.get(payloadData.senderName)) {\n//       privateChats.get(payloadData.senderName).push(payloadData);\n//       setPrivateChats(new Map(privateChats));\n//     } else {\n//       let list = [];\n//       list.push(payloadData);\n//       privateChats.set(payloadData.senderName, list);\n//       setPrivateChats(new Map(privateChats));\n//     }\n//     if (tab !== payloadData.senderName) {\n//       setUnreadMessages(prevUnreadMessages => {\n//         const newUnreadMessages = new Map(prevUnreadMessages);\n//         const count = newUnreadMessages.get(payloadData.senderName) || 0;\n//         newUnreadMessages.set(payloadData.senderName, count + 1);\n//         return newUnreadMessages;\n//       });\n//     }\n//   }*/\n//     /*\n//     const onPrivateMessage = (payload) => {\n//       const payloadData = JSON.parse(payload.body);\n//       // Agregar mensaje al chat privado del remitente\n//       if (privateChats.get(payloadData.senderName)) {\n//           privateChats.get(payloadData.senderName).push(payloadData);\n//       } else {\n//           let list = [];\n//           list.push(payloadData);\n//           privateChats.set(payloadData.senderName, list);\n//       }\n//       setPrivateChats(new Map(privateChats));\n//       if (tab !== payloadData.senderName) {\n//           setUnreadMessages(prevUnreadMessages => {\n//               const newUnreadMessages = new Map(prevUnreadMessages);\n//               const count = newUnreadMessages.get(payloadData.senderName) || 0;\n//               newUnreadMessages.set(payloadData.senderName, count + 1);\n//               return newUnreadMessages;\n//           });\n//       }\n//   };*/\n//   const onPrivateMessage = (payload) => {\n//     const payloadData = JSON.parse(payload.body);\n//     // Agregar mensaje al chat privado del remitente\n//     if (privateChats.get(payloadData.senderName)) {\n//         privateChats.get(payloadData.senderName).push(payloadData);\n//     } else {\n//         let list = [];\n//         list.push(payloadData);\n//         privateChats.set(payloadData.senderName, list);\n//     }\n//     setPrivateChats(new Map(privateChats));\n//     if (tab !== payloadData.senderName) {\n//         setUnreadMessages(prevUnreadMessages => {\n//             const newUnreadMessages = new Map(prevUnreadMessages);\n//             const count = newUnreadMessages.get(payloadData.senderName) || 0;\n//             newUnreadMessages.set(payloadData.senderName, count + 1);\n//             return newUnreadMessages;\n//         });\n//     }\n// };\n//     const updateUserOnlineStatus = (username, online) => {\n//       setAllUsers(prevUsers => prevUsers.map(user =>\n//           user.username === username ? { ...user, online } : user\n//       ));\n//   };\n//   const renderUserStatus = (user) => {\n//     return user.online ? (\n//         <span style={{ color: 'green' }}>Online</span>\n//     ) : (\n//         <span style={{ color: 'red' }}>Offline</span>\n//     );\n// };\n// const renderUserList = () => {\n//   return allUsers.map(user => (\n//       <div key={user.username} style={{ margin: '10px 0' }}>\n//           <span>{user.username}</span> {renderUserStatus(user)}\n//       </div>\n//   ));\n// };\n//   const handleTabChange = (name) => {\n//     setTab(name);\n//     setUnreadMessages(prevUnreadMessages => {\n//       const newUnreadMessages = new Map(prevUnreadMessages);\n//       newUnreadMessages.delete(name);\n//       return newUnreadMessages;\n//     });\n//   };\n//   const handleSearch = (event) => {\n//     const query = event.target.value;\n//     setSearchQuery(query);\n//     if (query.length > 0) {\n//       searchUsers(query);\n//     } else {\n//       fetchAllUsers();\n//     }\n//   };\n//   const onError = (err) => {\n//     console.log(err);\n//   }\n//   const handleMessage = (event) => {\n//     const { value } = event.target;\n//     setUserData({ ...userData, message: value });\n//   }\n//   const sendValue = () => {\n//     if (stompClient) {\n//       var chatMessage = {\n//         senderName: userData.username,\n//         message: userData.message,\n//         status: \"MESSAGE\"\n//       };\n//       stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\n//       setUserData({ ...userData, message: \"\" });\n//     }\n//   }\n//   const handleUsername = (event) => {\n//     const { name, value } = event.target;\n//     if (name === \"username\") {\n//       const filteredValue = value.replace(/[^a-zA-Z0-9\\s]/g, '');\n//       setUserData({ ...userData, [name]: filteredValue });\n//     } else {\n//       setUserData({ ...userData, [name]: value });\n//       const sanitizedValue = DOMPurify.sanitize(value);\n//       setUserData({ ...userData, [name]: sanitizedValue });\n//     }\n//   };\n//   const validateEmail = (email) => {\n//     const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n//     return re.test(String(email).toLowerCase());\n//   };\n//   const validateUsername = (username) => {\n//     const re = /^[a-zA-Z]+$/;\n//     return re.test(username);\n//   };\n//   const validateFields = () => {\n//     const errors = {};\n//     if (!userData.username || !validateUsername(userData.username)) {\n//       errors.username = \"El nombre de usuario solo puede contener letras\";\n//     }\n//     if (!userData.password) {\n//       errors.password = \"La contraseña no puede estar vacía\";\n//     }\n//     if (!userData.email || !validateEmail(userData.email)) {\n//       errors.email = \"El email no es válido\";\n//     }\n//     return errors;\n//   };\n//   const registerUser = async () => {\n//     const errors = validateFields();\n//     if (Object.keys(errors).length > 0) {\n//       setUserData({ ...userData, errors });\n//       return;\n//     }\n//     try {\n//       const response = await axios.post('http://localhost:8080/api/auth/register', {\n//         username: userData.username,\n//         password: userData.password,\n//         email: userData.email\n//       });\n//       console.log(response.data);\n//       setIsRegistering(false);\n//     } catch (error) {\n//       console.error('Registration failed:', error.response.data);\n//     }\n//   }\n//   const validateLoginFields = () => {\n//     const errors = {};\n//     if (!userData.username) {\n//       errors.username = \"El nombre de usuario no puede estar vacío\";\n//     }\n//     if (!userData.password) {\n//       errors.password = \"La contraseña no puede estar vacía\";\n//     }\n//     return errors;\n//   };\n//   const loginUser = async () => {\n//     const errors = validateLoginFields();\n//     if (Object.keys(errors).length > 0) {\n//       setUserData({ ...userData, errors });\n//       return;\n//     }\n//     try {\n//       const response = await axios.post('http://localhost:8080/api/auth/login', {\n//         username: userData.username,\n//         password: userData.password\n//       });\n//       console.log(response.data);\n//       setUserData({ ...userData, connected: true, errors: {} });\n//     } catch (error) {\n//       console.error('Login failed:', error.response.data);\n//       setUserData({ ...userData, errors: { ...errors, login: 'Nombre de usuario o contraseña incorrectos' } });\n//     }\n//   };\n//   return (\n//     <ChatRoomUI\n//       userData={userData}\n//       privateChats={privateChats}\n//       publicChats={publicChats}\n//       tab={tab}\n//       setTab={handleTabChange}\n//       handleMessage={handleMessage}\n//       sendValue={sendValue}\n//       sendPrivateValue={sendPrivateValue}\n//       handleUsername={handleUsername}\n//       registerUser={registerUser}\n//       loginUser={loginUser}\n//       unreadMessages={unreadMessages}\n//       isRegistering={isRegistering}\n//       setIsRegistering={setIsRegistering}\n//       allUsers={allUsers}\n//       searchQuery={searchQuery}\n//       setSearchQuery={setSearchQuery}\n//       searchUsers={searchUsers}\n//       renderUserStatus={searchUsers}\n//       renderUserList={searchUsers}\n//     />\n//   );\n// }\n// export default ChatRoom;","map":{"version":3,"sources":["C:/Users/USER/Documents/GitHub/Distribuidas/Distribuidas/PARCIAL II/PROYECTO/react-client/src/components/ChatRoom.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA","sourcesContent":["// import React, { useEffect, useState } from 'react';\r\n// import { over } from 'stompjs';\r\n// import SockJS from 'sockjs-client';\r\n// import ChatRoomUI from './ChatRoomUI';\r\n// import axios from 'axios';\r\n// import DOMPurify from 'dompurify';\r\n\r\n// let stompClient = null;\r\n\r\n// const ChatRoom = () => {\r\n//   const [privateChats, setPrivateChats] = useState(new Map());\r\n//   const [publicChats, setPublicChats] = useState([]);\r\n//   const [tab, setTab] = useState(\"CHATROOM\");\r\n//   const [unreadMessages, setUnreadMessages] = useState(new Map());\r\n//   const [allUsers, setAllUsers] = useState([]);\r\n//   const [searchQuery, setSearchQuery] = useState('');\r\n\r\n//   const [userData, setUserData] = useState({\r\n//     username: '',\r\n//     password: '',\r\n//     email: '',\r\n//     receivername: '',\r\n//     connected: false,\r\n//     message: '',\r\n//     errors: {}\r\n//   });\r\n//   const [isRegistering, setIsRegistering] = useState(false);\r\n\r\n//   useEffect(() => {\r\n//     if (userData.connected) {\r\n//       connect();\r\n//       fetchAllUsers();\r\n//       loadChatHistory();\r\n\r\n\r\n//     }\r\n//   }, [userData.connected]);\r\n\r\n//   useEffect(() => {\r\n//     if (tab !== \"CHATROOM\" && userData.connected) {\r\n//       loadPrivateChatHistory(tab);\r\n//     }\r\n//   }, [tab]);\r\n\r\n//   /*\r\n//   const loadPrivateChatHistory = async (receiverName) => {\r\n//     try {\r\n//       const response = await axios.get(`http://localhost:8080/api/chats/history?senderName=${userData.username}&receiverName=${receiverName}`);\r\n//       setPrivateChats(new Map(privateChats.set(receiverName, response.data)));\r\n//     } catch (error) {\r\n//       console.error('Error loading private chat history:', error);\r\n//     }\r\n//   };*/\r\n  \r\n//   const loadPrivateChatHistory = async (receiverName) => {\r\n//     try {\r\n//         const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=${receiverName}`);\r\n//         const sortedMessages = response.data.sort((a, b) => new Date(a.date) - new Date(b.date));\r\n//         setPrivateChats(new Map(privateChats.set(receiverName, sortedMessages)));\r\n//     } catch (error) {\r\n//         console.error('Error loading private chat history:', error);\r\n//     }\r\n//   };\r\n  \r\n\r\n\r\n//   const connect = () => {\r\n//     let Sock = new SockJS('http://localhost:8080/ws');\r\n//     stompClient = over(Sock);\r\n//     stompClient.connect({username: userData.username}, onConnected, onError);\r\n//   }\r\n\r\n//   const onConnected = () => {\r\n//     setUserData({ ...userData, connected: true });\r\n//     stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n//     stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n//     userJoin();\r\n//     fetchAllUsers();\r\n//     loadChatHistory();\r\n//   }\r\n\r\n//   const userJoin = () => {\r\n//     var chatMessage = {\r\n//       senderName: userData.username,\r\n//       status: \"JOIN\"\r\n//     };\r\n//     stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n//   }\r\n//   const fetchAllUsers = async () => {\r\n//     try {\r\n//       const response = await axios.get('http://localhost:8080/api/users/all');\r\n//       setAllUsers(response.data);\r\n//     } catch (error) {\r\n//       console.error('Failed to fetch users:', error);\r\n//     }\r\n//   };\r\n\r\n//   const sendPrivateValue = () => {\r\n//     if (stompClient) {\r\n//         var chatMessage = {\r\n//             senderName: userData.username,\r\n//             receiverName: tab,\r\n//             message: userData.message,\r\n//             status: \"MESSAGE\"\r\n//         };\r\n\r\n//         if (userData.username !== tab) {\r\n//             let msgs = privateChats.get(tab) || [];\r\n//             msgs.push(chatMessage);\r\n//             setPrivateChats(new Map(privateChats.set(tab, msgs)));\r\n//         }\r\n//         stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n//         setUserData({ ...userData, message: \"\" });\r\n//     }\r\n// }\r\n// /*\r\n// const sendPrivateValue = () => {\r\n//   if (stompClient) {\r\n//       var chatMessage = {\r\n//           senderName: userData.username,\r\n//           receiverName: tab,\r\n//           message: userData.message,\r\n//           status: \"MESSAGE\"\r\n//       };\r\n\r\n//       if (userData.username !== tab) {\r\n//           let msgs = privateChats.get(tab) || [];\r\n//           msgs.push(chatMessage);\r\n//           setPrivateChats(new Map(privateChats.set(tab, msgs)));\r\n//       }\r\n//       stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n//       setUserData({ ...userData, message: \"\" });\r\n//   }\r\n// }*/\r\n\r\n\r\n// const searchUsers = async () => {\r\n//     try {\r\n//         const response = await axios.get(`http://localhost:8080/api/users/search`, {\r\n//             params: { query: searchQuery }\r\n//         });\r\n//         setAllUsers(response.data);\r\n//     } catch (error) {\r\n//         console.error('Error searching users:', error);\r\n//     }\r\n// };\r\n// /*\r\n//   const loadChatHistory = async () => {\r\n//     try {\r\n//         const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=ALL`);\r\n//         setPublicChats(response.data);\r\n        \r\n//     } catch (error) {\r\n//         console.error('Error loading chat history:', error);\r\n//     }\r\n// };*/\r\n// /*\r\n// const loadChatHistory = async () => {\r\n//   try {\r\n//       // Obtener mensajes públicos\r\n//       const publicResponse = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=ALL`);\r\n//       setPublicChats(publicResponse.data);\r\n\r\n//       // Obtener mensajes privados\r\n//       const privateResponse = await axios.get(`http://localhost:8080/api/chats/history?senderName=${userData.username}&receiverName=${userData.username}`);\r\n//       privateResponse.data.forEach(chat => {\r\n//           let messages = privateChats.get(chat.receiverName) || [];\r\n//           messages.push(chat);\r\n//           setPrivateChats(new Map(privateChats.set(chat.receiverName, messages)));\r\n//       });\r\n\r\n//   } catch (error) {\r\n//       console.error('Error loading chat history:', error);\r\n//   }\r\n// };*/\r\n\r\n// const loadChatHistory = async () => {\r\n//   try {\r\n//       const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=ALL`);\r\n//       const sortedMessages = response.data.sort((a, b) => new Date(a.date) - new Date(b.date));\r\n//       setPublicChats(sortedMessages);\r\n//   } catch (error) {\r\n//       console.error('Error loading chat history:', error);\r\n//   }\r\n// };\r\n\r\n// // In the useEffect hook\r\n// useEffect(() => {\r\n//   if (userData.connected) {\r\n//       connect();\r\n//       fetchAllUsers();\r\n//       loadChatHistory();\r\n//   }\r\n// }, [userData.connected]);\r\n\r\n// useEffect(() => {\r\n//   if (tab !== \"CHATROOM\" && userData.connected) {\r\n//       loadPrivateChatHistory(tab);\r\n//   }\r\n// }, [tab]);\r\n\r\n\r\n\r\n// /*\r\n//   const onMessageReceived = (payload) => {\r\n//     var payloadData = JSON.parse(payload.body);\r\n//     switch (payloadData.status) {\r\n//       case \"JOIN\":\r\n//         if (!privateChats.get(payloadData.senderName)) {\r\n//           privateChats.set(payloadData.senderName, []);\r\n//           setPrivateChats(new Map(privateChats));\r\n//         }\r\n//         break;\r\n//       case \"MESSAGE\":\r\n//         publicChats.push(payloadData);\r\n//         setPublicChats([...publicChats]);\r\n//         break;\r\n//     }\r\n//   }\r\n//   */\r\n//     const onMessageReceived = (payload) => {\r\n//       var payloadData = JSON.parse(payload.body);\r\n//       switch (payloadData.status) {\r\n//           case \"JOIN\":\r\n//               if (!privateChats.get(payloadData.senderName)) {\r\n//                   privateChats.set(payloadData.senderName, []);\r\n//                   setPrivateChats(new Map(privateChats));\r\n//               }\r\n//               fetchAllUsers();\r\n//               break;\r\n//           case \"MESSAGE\":\r\n//               publicChats.push(payloadData);\r\n//               setPublicChats([...publicChats]);\r\n//               break;\r\n//           case \"NEW_USER\":\r\n//             fetchAllUsers(); // Actualizar la lista de usuarios cuando un nuevo usuario se registra\r\n//             break;\r\n//           default:\r\n//               setAllUsers([...allUsers, payloadData]);\r\n//               break;\r\n//       }\r\n//   }\r\n  \r\n//   const sanitizeInput = (input) => {\r\n//     return DOMPurify.sanitize(input);\r\n//   };\r\n// /*\r\n//   const onPrivateMessage = (payload) => {\r\n//     var payloadData = JSON.parse(payload.body);\r\n//     if (privateChats.get(payloadData.senderName)) {\r\n//       privateChats.get(payloadData.senderName).push(payloadData);\r\n//       setPrivateChats(new Map(privateChats));\r\n//     } else {\r\n//       let list = [];\r\n//       list.push(payloadData);\r\n//       privateChats.set(payloadData.senderName, list);\r\n//       setPrivateChats(new Map(privateChats));\r\n//     }\r\n\r\n//     if (tab !== payloadData.senderName) {\r\n//       setUnreadMessages(prevUnreadMessages => {\r\n//         const newUnreadMessages = new Map(prevUnreadMessages);\r\n//         const count = newUnreadMessages.get(payloadData.senderName) || 0;\r\n//         newUnreadMessages.set(payloadData.senderName, count + 1);\r\n//         return newUnreadMessages;\r\n//       });\r\n//     }\r\n//   }*/\r\n\r\n//     /*\r\n//     const onPrivateMessage = (payload) => {\r\n//       const payloadData = JSON.parse(payload.body);\r\n  \r\n//       // Agregar mensaje al chat privado del remitente\r\n//       if (privateChats.get(payloadData.senderName)) {\r\n//           privateChats.get(payloadData.senderName).push(payloadData);\r\n//       } else {\r\n//           let list = [];\r\n//           list.push(payloadData);\r\n//           privateChats.set(payloadData.senderName, list);\r\n//       }\r\n//       setPrivateChats(new Map(privateChats));\r\n  \r\n//       if (tab !== payloadData.senderName) {\r\n//           setUnreadMessages(prevUnreadMessages => {\r\n//               const newUnreadMessages = new Map(prevUnreadMessages);\r\n//               const count = newUnreadMessages.get(payloadData.senderName) || 0;\r\n//               newUnreadMessages.set(payloadData.senderName, count + 1);\r\n//               return newUnreadMessages;\r\n//           });\r\n//       }\r\n//   };*/\r\n\r\n//   const onPrivateMessage = (payload) => {\r\n//     const payloadData = JSON.parse(payload.body);\r\n\r\n//     // Agregar mensaje al chat privado del remitente\r\n//     if (privateChats.get(payloadData.senderName)) {\r\n//         privateChats.get(payloadData.senderName).push(payloadData);\r\n//     } else {\r\n//         let list = [];\r\n//         list.push(payloadData);\r\n//         privateChats.set(payloadData.senderName, list);\r\n//     }\r\n//     setPrivateChats(new Map(privateChats));\r\n\r\n//     if (tab !== payloadData.senderName) {\r\n//         setUnreadMessages(prevUnreadMessages => {\r\n//             const newUnreadMessages = new Map(prevUnreadMessages);\r\n//             const count = newUnreadMessages.get(payloadData.senderName) || 0;\r\n//             newUnreadMessages.set(payloadData.senderName, count + 1);\r\n//             return newUnreadMessages;\r\n//         });\r\n//     }\r\n// };\r\n\r\n  \r\n\r\n//     const updateUserOnlineStatus = (username, online) => {\r\n//       setAllUsers(prevUsers => prevUsers.map(user =>\r\n//           user.username === username ? { ...user, online } : user\r\n//       ));\r\n//   };\r\n  \r\n//   const renderUserStatus = (user) => {\r\n//     return user.online ? (\r\n//         <span style={{ color: 'green' }}>Online</span>\r\n//     ) : (\r\n//         <span style={{ color: 'red' }}>Offline</span>\r\n//     );\r\n// };\r\n\r\n// const renderUserList = () => {\r\n//   return allUsers.map(user => (\r\n//       <div key={user.username} style={{ margin: '10px 0' }}>\r\n//           <span>{user.username}</span> {renderUserStatus(user)}\r\n//       </div>\r\n//   ));\r\n// };\r\n  \r\n\r\n//   const handleTabChange = (name) => {\r\n//     setTab(name);\r\n//     setUnreadMessages(prevUnreadMessages => {\r\n//       const newUnreadMessages = new Map(prevUnreadMessages);\r\n//       newUnreadMessages.delete(name);\r\n//       return newUnreadMessages;\r\n//     });\r\n//   };\r\n  \r\n//   const handleSearch = (event) => {\r\n//     const query = event.target.value;\r\n//     setSearchQuery(query);\r\n//     if (query.length > 0) {\r\n//       searchUsers(query);\r\n//     } else {\r\n//       fetchAllUsers();\r\n//     }\r\n//   };\r\n\r\n\r\n//   const onError = (err) => {\r\n//     console.log(err);\r\n//   }\r\n\r\n//   const handleMessage = (event) => {\r\n//     const { value } = event.target;\r\n//     setUserData({ ...userData, message: value });\r\n//   }\r\n\r\n//   const sendValue = () => {\r\n//     if (stompClient) {\r\n//       var chatMessage = {\r\n//         senderName: userData.username,\r\n//         message: userData.message,\r\n//         status: \"MESSAGE\"\r\n//       };\r\n//       stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n//       setUserData({ ...userData, message: \"\" });\r\n//     }\r\n//   }\r\n\r\n  \r\n\r\n  \r\n//   const handleUsername = (event) => {\r\n//     const { name, value } = event.target;\r\n    \r\n//     if (name === \"username\") {\r\n//       const filteredValue = value.replace(/[^a-zA-Z0-9\\s]/g, '');\r\n//       setUserData({ ...userData, [name]: filteredValue });\r\n//     } else {\r\n//       setUserData({ ...userData, [name]: value });\r\n//       const sanitizedValue = DOMPurify.sanitize(value);\r\n//       setUserData({ ...userData, [name]: sanitizedValue });\r\n//     }\r\n//   };\r\n\r\n\r\n \r\n\r\n//   const validateEmail = (email) => {\r\n//     const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n//     return re.test(String(email).toLowerCase());\r\n//   };\r\n\r\n//   const validateUsername = (username) => {\r\n//     const re = /^[a-zA-Z]+$/;\r\n//     return re.test(username);\r\n//   };\r\n\r\n//   const validateFields = () => {\r\n//     const errors = {};\r\n//     if (!userData.username || !validateUsername(userData.username)) {\r\n//       errors.username = \"El nombre de usuario solo puede contener letras\";\r\n//     }\r\n//     if (!userData.password) {\r\n//       errors.password = \"La contraseña no puede estar vacía\";\r\n//     }\r\n//     if (!userData.email || !validateEmail(userData.email)) {\r\n//       errors.email = \"El email no es válido\";\r\n//     }\r\n//     return errors;\r\n//   };\r\n\r\n//   const registerUser = async () => {\r\n//     const errors = validateFields();\r\n//     if (Object.keys(errors).length > 0) {\r\n//       setUserData({ ...userData, errors });\r\n//       return;\r\n//     }\r\n//     try {\r\n//       const response = await axios.post('http://localhost:8080/api/auth/register', {\r\n//         username: userData.username,\r\n//         password: userData.password,\r\n//         email: userData.email\r\n//       });\r\n//       console.log(response.data);\r\n//       setIsRegistering(false);\r\n//     } catch (error) {\r\n//       console.error('Registration failed:', error.response.data);\r\n//     }\r\n//   }\r\n\r\n//   const validateLoginFields = () => {\r\n//     const errors = {};\r\n//     if (!userData.username) {\r\n//       errors.username = \"El nombre de usuario no puede estar vacío\";\r\n//     }\r\n//     if (!userData.password) {\r\n//       errors.password = \"La contraseña no puede estar vacía\";\r\n//     }\r\n//     return errors;\r\n//   };\r\n  \r\n//   const loginUser = async () => {\r\n//     const errors = validateLoginFields();\r\n//     if (Object.keys(errors).length > 0) {\r\n//       setUserData({ ...userData, errors });\r\n//       return;\r\n//     }\r\n//     try {\r\n//       const response = await axios.post('http://localhost:8080/api/auth/login', {\r\n//         username: userData.username,\r\n//         password: userData.password\r\n//       });\r\n//       console.log(response.data);\r\n//       setUserData({ ...userData, connected: true, errors: {} });\r\n//     } catch (error) {\r\n//       console.error('Login failed:', error.response.data);\r\n//       setUserData({ ...userData, errors: { ...errors, login: 'Nombre de usuario o contraseña incorrectos' } });\r\n//     }\r\n//   };\r\n\r\n  \r\n//   return (\r\n//     <ChatRoomUI\r\n//       userData={userData}\r\n//       privateChats={privateChats}\r\n//       publicChats={publicChats}\r\n//       tab={tab}\r\n//       setTab={handleTabChange}\r\n//       handleMessage={handleMessage}\r\n//       sendValue={sendValue}\r\n//       sendPrivateValue={sendPrivateValue}\r\n//       handleUsername={handleUsername}\r\n//       registerUser={registerUser}\r\n//       loginUser={loginUser}\r\n//       unreadMessages={unreadMessages}\r\n//       isRegistering={isRegistering}\r\n//       setIsRegistering={setIsRegistering}\r\n//       allUsers={allUsers}\r\n//       searchQuery={searchQuery}\r\n//       setSearchQuery={setSearchQuery}\r\n//       searchUsers={searchUsers}\r\n//       renderUserStatus={searchUsers}\r\n//       renderUserList={searchUsers}\r\n\r\n//     />\r\n//   );\r\n// }\r\n\r\n// export default ChatRoom;\r\n\r\n\r\n\r\n\r\n\r\n"]},"metadata":{},"sourceType":"module"}