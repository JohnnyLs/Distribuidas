{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\USER\\\\Documents\\\\GitHub\\\\Distribuidas\\\\Distribuidas\\\\PARCIAL II\\\\PROYECTO\\\\react-client\\\\src\\\\components\\\\ChatRoom.js\",\n    _s = $RefreshSig$();\n\n/* \r\n//ESTE ESTA BIEN\r\n\r\nimport React, { useEffect, useState } from 'react';\r\nimport { over } from 'stompjs';\r\nimport SockJS from 'sockjs-client';\r\nimport ChatRoomUI from './ChatRoomUI';\r\nimport axios from 'axios';\r\nimport DOMPurify from 'dompurify';\r\n\r\nlet stompClient = null;\r\n\r\nconst ChatRoom = () => {\r\n  const [privateChats, setPrivateChats] = useState(new Map());\r\n  const [publicChats, setPublicChats] = useState([]);\r\n  const [tab, setTab] = useState(\"CHATROOM\");\r\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\r\n  const [allUsers, setAllUsers] = useState([]);\r\n  const [searchQuery, setSearchQuery] = useState('');\r\n\r\n  const [userData, setUserData] = useState({\r\n    username: '',\r\n    password: '',\r\n    email: '',\r\n    receivername: '',\r\n    connected: false,\r\n    message: '',\r\n    errors: {}\r\n  });\r\n  const [isRegistering, setIsRegistering] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (userData.connected) {\r\n      connect();\r\n      fetchAllUsers();\r\n      loadChatHistory();\r\n    }\r\n  }, [userData.connected]);\r\n\r\n  useEffect(() => {\r\n    if (tab !== \"CHATROOM\" && userData.connected) {\r\n      loadPrivateChatHistory(tab);\r\n    }\r\n  }, [tab]);\r\n\r\n  const loadPrivateChatHistory = async (receiverName) => {\r\n    if (receiverName === userData.username && tab === receiverName) {\r\n      return;\r\n    }\r\n  \r\n    try {\r\n      const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=${receiverName}`);\r\n      const sortedMessages = response.data\r\n        .filter(msg => msg.message.trim() !== '') // Filtrar mensajes vacíos\r\n        .sort((a, b) => new Date(a.date) - new Date(b.date));\r\n      const uniqueMessages = Array.from(new Map(sortedMessages.map(msg => [msg.id, msg])).values());\r\n  \r\n      setPrivateChats(prevChats => {\r\n        const updatedChats = new Map(prevChats);\r\n        updatedChats.set(receiverName, uniqueMessages);\r\n        return updatedChats;\r\n      });\r\n    } catch (error) {\r\n      console.error('Error loading private chat history:', error);\r\n    }\r\n  };\r\n\r\n  const connect = () => {\r\n    let Sock = new SockJS('http://localhost:8080/ws');\r\n    stompClient = over(Sock);\r\n    stompClient.connect({ username: userData.username }, onConnected, onError);\r\n  }\r\n\r\n  const onConnected = () => {\r\n    setUserData({ ...userData, connected: true });\r\n    stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n    stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n    userJoin();\r\n    fetchAllUsers();\r\n    loadChatHistory();\r\n  }\r\n\r\n  const userJoin = () => {\r\n    var chatMessage = {\r\n      senderName: userData.username,\r\n      status: \"JOIN\"\r\n    };\r\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n  }\r\n\r\n  const fetchAllUsers = async () => {\r\n    try {\r\n      const response = await axios.get('http://localhost:8080/api/users/all');\r\n      setAllUsers(response.data);\r\n    } catch (error) {\r\n      console.error('Failed to fetch users:', error);\r\n    }\r\n  };\r\n\r\n  const sendPrivateValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        receiverName: tab,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n\r\n      if (userData.username !== tab) {\r\n        let msgs = privateChats.get(tab) || [];\r\n        msgs.push(chatMessage);\r\n        setPrivateChats(new Map(privateChats.set(tab, msgs)));\r\n      }\r\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const searchUsers = async () => {\r\n    try {\r\n      const response = await axios.get(`http://localhost:8080/api/users/search`, {\r\n        params: { query: searchQuery }\r\n      });\r\n      setAllUsers(response.data);\r\n    } catch (error) {\r\n      console.error('Error searching users:', error);\r\n    }\r\n  };\r\n\r\n  const loadChatHistory = async () => {\r\n    try {\r\n      const response = await axios.get('http://localhost:8080/api/chats/history');\r\n      const sortedMessages = response.data\r\n        .filter(msg => msg.message && msg.message.trim() !== '') \r\n        .sort((a, b) => new Date(a.date) - new Date(b.date));\r\n      setPublicChats(sortedMessages);\r\n    } catch (error) {\r\n      console.error('Error loading chat history:', error);\r\n    }\r\n  };\r\n  \r\n  const onMessageReceived = (payload) => {\r\n    const payloadData = JSON.parse(payload.body);\r\n    switch (payloadData.status) {\r\n      case \"JOIN\":\r\n        if (!privateChats.get(payloadData.senderName)) {\r\n          privateChats.set(payloadData.senderName, []);\r\n          setPrivateChats(new Map(privateChats));\r\n        }\r\n        fetchAllUsers();\r\n        break;\r\n      case \"MESSAGE\":\r\n        if (payloadData.message.trim() !== '') { \r\n          setPublicChats(prevPublicChats => [...prevPublicChats, payloadData]);\r\n        }\r\n        break;\r\n      case \"NEW_USER\":\r\n        fetchAllUsers();\r\n        break;\r\n      default:\r\n        setAllUsers(prevAllUsers => [...prevAllUsers, payloadData]);\r\n        break;\r\n    }\r\n  };\r\n  \r\n  \r\n\r\n  const sanitizeInput = (input) => {\r\n    return DOMPurify.sanitize(input);\r\n  };\r\n\r\n  const onPrivateMessage = (payload) => {\r\n    const payloadData = JSON.parse(payload.body);\r\n  \r\n    if (payloadData.senderName === userData.username && tab === userData.username) {\r\n      return;\r\n    }\r\n  \r\n    if (payloadData.message.trim() === '') { \r\n      return;\r\n    }\r\n  \r\n    setPrivateChats(prevChats => {\r\n      const updatedChats = new Map(prevChats);\r\n      const currentMessages = updatedChats.get(payloadData.senderName) || [];\r\n      const isDuplicate = currentMessages.some(msg => msg.id === payloadData.id);\r\n      if (!isDuplicate) {\r\n        updatedChats.set(payloadData.senderName, [...currentMessages, payloadData]);\r\n      }\r\n      return updatedChats;\r\n    });\r\n  \r\n    if (tab !== payloadData.senderName) {\r\n      setUnreadMessages(prevUnreadMessages => {\r\n        const newUnreadMessages = new Map(prevUnreadMessages);\r\n        const count = newUnreadMessages.get(payloadData.senderName) || 0;\r\n        newUnreadMessages.set(payloadData.senderName, count + 1);\r\n        return newUnreadMessages;\r\n      });\r\n    }\r\n  };\r\n  \r\n  const updateUserOnlineStatus = (username, online) => {\r\n    setAllUsers(prevUsers => prevUsers.map(user =>\r\n      user.username === username ? { ...user, online } : user\r\n    ));\r\n  };\r\n\r\n  const renderUserStatus = (user) => {\r\n    return user.online ? (\r\n      <span style={{ color: 'green' }}>Online</span>\r\n    ) : (\r\n      <span style={{ color: 'red' }}>Offline</span>\r\n    );\r\n  };\r\n\r\n  const renderUserList = () => {\r\n    return allUsers.map(user => (\r\n      <div key={user.username} style={{ margin: '10px 0' }}>\r\n        <span>{user.username}</span> {renderUserStatus(user)}\r\n      </div>\r\n    ));\r\n  };\r\n\r\n  const handleTabChange = (name) => {\r\n    setTab(name);\r\n\r\n    setUnreadMessages(prevUnreadMessages => {\r\n      const newUnreadMessages = new Map(prevUnreadMessages);\r\n      newUnreadMessages.delete(name);\r\n      return newUnreadMessages;\r\n    });\r\n\r\n    if (name !== \"CHATROOM\") {\r\n      loadPrivateChatHistory(name);\r\n    }\r\n  };\r\n\r\n  const handleSearch = (event) => {\r\n    const query = event.target.value;\r\n    setSearchQuery(query);\r\n    if (query.length > 0) {\r\n      searchUsers(query);\r\n    } else {\r\n      fetchAllUsers();\r\n    }\r\n  };\r\n\r\n  const onError = (err) => {\r\n    console.log(err);\r\n  }\r\n\r\n  const handleMessage = (event) => {\r\n    const { value } = event.target;\r\n    setUserData({ ...userData, message: value });\r\n  }\r\n\r\n    const sendValue = () => {\r\n      if (stompClient) {\r\n        const chatMessage = {\r\n          senderName: userData.username,\r\n          message: userData.message,\r\n          status: \"MESSAGE\"\r\n        };\r\n        stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n        setUserData(prevUserData => ({ ...prevUserData, message: \"\" }));\r\n      }\r\n    };\r\n    \r\n\r\n  const handleUsername = (event) => {\r\n    const { name, value } = event.target;\r\n    if (name === \"username\") {\r\n      const filteredValue = value.replace(/[^a-zA-Z0-9\\s]/g, '');\r\n      setUserData({ ...userData, [name]: filteredValue });\r\n    } else {\r\n      setUserData({ ...userData, [name]: value });\r\n      const sanitizedValue = DOMPurify.sanitize(value);\r\n      setUserData({ ...userData, [name]: sanitizedValue });\r\n    }\r\n  };\r\n\r\n  const validateEmail = (email) => {\r\n    const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n    return re.test(String(email).toLowerCase());\r\n  };\r\n\r\n  const validateUsername = (username) => {\r\n    const re = /^[a-zA-Z]+$/;\r\n    return re.test(username);\r\n  };\r\n\r\n  const validateFields = () => {\r\n    const errors = {};\r\n    if (!userData.username || !validateUsername(userData.username)) {\r\n      errors.username = \"El nombre de usuario solo puede contener letras\";\r\n    }\r\n    if (!userData.password) {\r\n      errors.password = \"La contraseña no puede estar vacía\";\r\n    }\r\n    if (!userData.email || !validateEmail(userData.email)) {\r\n      errors.email = \"El email no es válido\";\r\n    }\r\n    return errors;\r\n  };\r\n\r\n  const registerUser = async () => {\r\n    const errors = validateFields();\r\n    if (Object.keys(errors).length > 0) {\r\n      setUserData({ ...userData, errors });\r\n      return;\r\n    }\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/register', {\r\n        username: userData.username,\r\n        password: userData.password,\r\n        email: userData.email\r\n      });\r\n      console.log(response.data);\r\n      setIsRegistering(false);\r\n    } catch (error) {\r\n      console.error('Registration failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  const validateLoginFields = () => {\r\n    const errors = {};\r\n    if (!userData.username) {\r\n      errors.username = \"El nombre de usuario no puede estar vacío\";\r\n    }\r\n    if (!userData.password) {\r\n      errors.password = \"La contraseña no puede estar vacía\";\r\n    }\r\n    return errors;\r\n  };\r\n  \r\n  const loginUser = async () => {\r\n    const errors = validateLoginFields();\r\n    if (Object.keys(errors).length > 0) {\r\n      setUserData({ ...userData, errors });\r\n      return;\r\n    }\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/login', {\r\n        username: userData.username,\r\n        password: userData.password\r\n      });\r\n      console.log(response.data);\r\n      setUserData({ ...userData, connected: true, errors: {} });\r\n    } catch (error) {\r\n      console.error('Login failed:', error.response.data);\r\n      setUserData({ ...userData, errors: { ...errors, login: 'Nombre de usuario o contraseña incorrectos' } });\r\n    }\r\n  };\r\n\r\n  const handleLogout = () => {\r\n    setUserData({ ...userData, connected: false });\r\n    stompClient.disconnect();\r\n    window.location.href = \"/login\";  \r\n  }\r\n  \r\n  return (\r\n    <ChatRoomUI\r\n      userData={userData}\r\n      privateChats={privateChats}\r\n      publicChats={publicChats}\r\n      tab={tab}\r\n      setTab={handleTabChange}\r\n      handleMessage={handleMessage}\r\n      sendValue={sendValue}\r\n      sendPrivateValue={sendPrivateValue}\r\n      handleUsername={handleUsername}\r\n      registerUser={registerUser}\r\n      loginUser={loginUser}\r\n      unreadMessages={unreadMessages}\r\n      isRegistering={isRegistering}\r\n      setIsRegistering={setIsRegistering}\r\n      allUsers={allUsers}\r\n      searchQuery={searchQuery}\r\n      setSearchQuery={setSearchQuery}\r\n      searchUsers={searchUsers}\r\n      renderUserStatus={searchUsers}\r\n      renderUserList={searchUsers}\r\n      logoutUser={handleLogout}\r\n    />\r\n  );\r\n}\r\n\r\nexport default ChatRoom;\r\n\r\n\r\n\r\n*/\nimport React, { useEffect, useState } from 'react';\nimport { over } from 'stompjs';\nimport SockJS from 'sockjs-client';\nimport ChatRoomUI from './ChatRoomUI';\nimport axios from 'axios';\nimport DOMPurify from 'dompurify';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet stompClient = null;\n\nconst ChatRoom = () => {\n  _s();\n\n  const [privateChats, setPrivateChats] = useState(new Map());\n  const [publicChats, setPublicChats] = useState([]);\n  const [tab, setTab] = useState(\"CHATROOM\");\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\n  const [allUsers, setAllUsers] = useState([]);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [userData, setUserData] = useState({\n    username: '',\n    password: '',\n    email: '',\n    receivername: '',\n    connected: false,\n    message: '',\n    errors: {}\n  });\n  const [isRegistering, setIsRegistering] = useState(false);\n  useEffect(() => {\n    if (userData.connected) {\n      connect();\n      fetchAllUsers();\n      loadChatHistory();\n    }\n  }, [userData.connected]);\n  useEffect(() => {\n    if (tab !== \"CHATROOM\" && userData.connected) {\n      loadPrivateChatHistory(tab);\n    }\n  }, [tab]);\n\n  const loadPrivateChatHistory = async receiverName => {\n    if (receiverName === userData.username && tab === receiverName) {\n      return;\n    }\n\n    try {\n      const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=${receiverName}`);\n      const sortedMessages = response.data.filter(msg => msg.message.trim() !== '') // Filtrar mensajes vacíos\n      .sort((a, b) => new Date(a.date) - new Date(b.date));\n      const uniqueMessages = Array.from(new Map(sortedMessages.map(msg => [msg.id, msg])).values());\n      setPrivateChats(prevChats => {\n        const updatedChats = new Map(prevChats);\n        updatedChats.set(receiverName, uniqueMessages);\n        return updatedChats;\n      });\n    } catch (error) {\n      console.error('Error loading private chat history:', error);\n    }\n  };\n\n  const connect = () => {\n    let Sock = new SockJS('http://localhost:8080/ws');\n    stompClient = over(Sock);\n    stompClient.connect({\n      username: userData.username\n    }, onConnected, onError);\n  };\n\n  const onConnected = () => {\n    console.log('Connected to WebSocket');\n    stompClient.subscribe('/topic/user-status', onUserStatusUpdate);\n    stompClient.subscribe('/chatroom/public', onMessageReceived);\n    stompClient.subscribe(`/user/${userData.username}/private`, onPrivateMessage); // Opcional: Envía un mensaje al servidor para confirmar que el usuario está en línea\n\n    sendOnlineStatus(true);\n  };\n\n  const sendOnlineStatus = isOnline => {\n    fetch('/api/users/status', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        username: userData.username,\n        isOnline\n      })\n    }).then(response => {\n      if (!response.ok) {\n        console.error('Failed to update user status');\n      }\n    }).catch(error => {\n      console.error('Error updating user status:', error);\n    });\n  };\n\n  const updateUserStatus = async (username, isOnline) => {\n    try {\n      await axios.post('http://localhost:8080/api/users/status', {\n        username,\n        isOnline\n      });\n      updateUserOnlineStatus(username, isOnline);\n    } catch (error) {\n      console.error('Error updating user status:', error);\n    }\n  };\n\n  const userJoin = () => {\n    var chatMessage = {\n      senderName: userData.username,\n      status: \"JOIN\"\n    };\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\n  };\n\n  const fetchAllUsers = async () => {\n    try {\n      const response = await axios.get('http://localhost:8080/api/users/all');\n      setAllUsers(response.data);\n    } catch (error) {\n      console.error('Failed to fetch users:', error);\n    }\n  };\n\n  const sendPrivateValue = () => {\n    if (stompClient) {\n      var chatMessage = {\n        senderName: userData.username,\n        receiverName: tab,\n        message: userData.message,\n        status: \"MESSAGE\"\n      };\n\n      if (userData.username !== tab) {\n        let msgs = privateChats.get(tab) || [];\n        msgs.push(chatMessage);\n        setPrivateChats(new Map(privateChats.set(tab, msgs)));\n      }\n\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\n      setUserData({ ...userData,\n        message: \"\"\n      });\n    }\n  };\n\n  const searchUsers = async () => {\n    try {\n      const response = await axios.get(`http://localhost:8080/api/users/search`, {\n        params: {\n          query: searchQuery\n        }\n      });\n      setAllUsers(response.data);\n    } catch (error) {\n      console.error('Error searching users:', error);\n    }\n  };\n\n  const loadChatHistory = async () => {\n    try {\n      const response = await axios.get('http://localhost:8080/api/chats/history');\n      const sortedMessages = response.data.filter(msg => msg.message && msg.message.trim() !== '').sort((a, b) => new Date(a.date) - new Date(b.date));\n      setPublicChats(sortedMessages);\n    } catch (error) {\n      console.error('Error loading chat history:', error);\n    }\n  };\n\n  const onMessageReceived = payload => {\n    const payloadData = JSON.parse(payload.body);\n\n    switch (payloadData.status) {\n      case \"JOIN\":\n        if (!privateChats.get(payloadData.senderName)) {\n          privateChats.set(payloadData.senderName, []);\n          setPrivateChats(new Map(privateChats));\n        }\n\n        fetchAllUsers();\n        break;\n\n      case \"MESSAGE\":\n        if (payloadData.message.trim() !== '') {\n          setPublicChats(prevPublicChats => [...prevPublicChats, payloadData]);\n        }\n\n        break;\n\n      case \"NEW_USER\":\n        fetchAllUsers();\n        break;\n\n      default:\n        setAllUsers(prevAllUsers => [...prevAllUsers, payloadData]);\n        break;\n    }\n  };\n\n  const sanitizeInput = input => {\n    return DOMPurify.sanitize(input);\n  };\n\n  const onPrivateMessage = payload => {\n    const payloadData = JSON.parse(payload.body);\n\n    if (payloadData.senderName === userData.username && tab === userData.username) {\n      return;\n    }\n\n    if (payloadData.message.trim() === '') {\n      return;\n    }\n\n    setPrivateChats(prevChats => {\n      const updatedChats = new Map(prevChats);\n      const currentMessages = updatedChats.get(payloadData.senderName) || [];\n      const isDuplicate = currentMessages.some(msg => msg.id === payloadData.id);\n\n      if (!isDuplicate) {\n        updatedChats.set(payloadData.senderName, [...currentMessages, payloadData]);\n      }\n\n      return updatedChats;\n    });\n\n    if (tab !== payloadData.senderName) {\n      setUnreadMessages(prevUnreadMessages => {\n        const newUnreadMessages = new Map(prevUnreadMessages);\n        const count = newUnreadMessages.get(payloadData.senderName) || 0;\n        newUnreadMessages.set(payloadData.senderName, count + 1);\n        return newUnreadMessages;\n      });\n    }\n  };\n\n  const updateUserOnlineStatus = (username, online) => {\n    setAllUsers(prevUsers => prevUsers.map(user => user.username === username ? { ...user,\n      online\n    } : user));\n  };\n\n  const handleTabChange = name => {\n    setTab(name);\n    setUnreadMessages(prevUnreadMessages => {\n      const newUnreadMessages = new Map(prevUnreadMessages);\n      newUnreadMessages.delete(name);\n      return newUnreadMessages;\n    });\n\n    if (name !== \"CHATROOM\") {\n      loadPrivateChatHistory(name);\n    }\n  };\n\n  const handleSearch = event => {\n    const query = event.target.value;\n    setSearchQuery(query);\n\n    if (query.length > 0) {\n      searchUsers(query);\n    } else {\n      fetchAllUsers();\n    }\n  };\n\n  const onError = err => {\n    console.log(err);\n  };\n\n  const handleMessage = event => {\n    const {\n      value\n    } = event.target;\n    setUserData({ ...userData,\n      message: value\n    });\n  };\n\n  const sendValue = () => {\n    if (stompClient) {\n      const chatMessage = {\n        senderName: userData.username,\n        message: userData.message,\n        status: \"MESSAGE\"\n      };\n      stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\n      setUserData(prevUserData => ({ ...prevUserData,\n        message: \"\"\n      }));\n    }\n  };\n\n  const handleUsername = event => {\n    const {\n      name,\n      value\n    } = event.target;\n\n    if (name === \"username\") {\n      const filteredValue = value.replace(/[^a-zA-Z0-9\\s]/g, '');\n      setUserData({ ...userData,\n        [name]: filteredValue\n      });\n    } else {\n      setUserData({ ...userData,\n        [name]: value\n      });\n      const sanitizedValue = DOMPurify.sanitize(value);\n      setUserData({ ...userData,\n        [name]: sanitizedValue\n      });\n    }\n  };\n\n  const validateEmail = email => {\n    const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return re.test(String(email).toLowerCase());\n  };\n\n  const validateUsername = username => {\n    const re = /^[a-zA-Z]+$/;\n    return re.test(username);\n  };\n\n  const validateFields = () => {\n    const errors = {};\n\n    if (!userData.username || !validateUsername(userData.username)) {\n      errors.username = \"El nombre de usuario solo puede contener letras\";\n    }\n\n    if (!userData.password) {\n      errors.password = \"La contraseña no puede estar vacía\";\n    }\n\n    if (!userData.email || !validateEmail(userData.email)) {\n      errors.email = \"El email no es válido\";\n    }\n\n    return errors;\n  };\n\n  const registerUser = async () => {\n    const errors = validateFields();\n\n    if (Object.keys(errors).length > 0) {\n      setUserData({ ...userData,\n        errors\n      });\n      return;\n    }\n\n    try {\n      const response = await axios.post('http://localhost:8080/api/auth/register', {\n        username: userData.username,\n        password: userData.password,\n        email: userData.email\n      });\n      console.log(response.data);\n      setIsRegistering(false);\n    } catch (error) {\n      console.error('Registration failed:', error.response.data);\n    }\n  };\n\n  const validateLoginFields = () => {\n    const errors = {};\n\n    if (!userData.username) {\n      errors.username = \"El nombre de usuario no puede estar vacío\";\n    }\n\n    if (!userData.password) {\n      errors.password = \"La contraseña no puede estar vacía\";\n    }\n\n    return errors;\n  };\n\n  const loginUser = async () => {\n    const errors = validateLoginFields();\n\n    if (Object.keys(errors).length > 0) {\n      setUserData({ ...userData,\n        errors\n      });\n      return;\n    }\n\n    try {\n      const response = await axios.post('http://localhost:8080/api/auth/login', {\n        username: userData.username,\n        password: userData.password\n      });\n      console.log(response.data);\n      setUserData({ ...userData,\n        connected: true,\n        errors: {}\n      });\n    } catch (error) {\n      console.error('Login failed:', error.response.data);\n      setUserData({ ...userData,\n        errors: { ...errors,\n          login: 'Nombre de usuario o contraseña incorrectos'\n        }\n      });\n    }\n  };\n  /*\r\n    const handleLogout = () => {\r\n      updateUserStatus(userData.username, false);\r\n      setUserData({ ...userData, connected: false });\r\n      stompClient.disconnect(() => {\r\n        window.location.href = \"/login\";\r\n      });\r\n    };*/\n\n\n  const handleLogout = () => {\n    // Desconectar el cliente STOMP\n    if (stompClient) {\n      stompClient.disconnect(() => {\n        console.log('Disconnected'); // Redirige al usuario a la página de inicio de sesión después de desconectar\n\n        window.location.href = '/login';\n      });\n    } else {\n      // Redirige al usuario a la página de inicio de sesión si no hay cliente STOMP\n      window.location.href = '/login';\n    }\n  };\n  /*\r\n      const handleLogout = () => {\r\n        updateUserStatus(userData.username, false);\r\n        setUserData({ ...userData, connected: false });\r\n        updateUserOnlineStatus(userData.username, false); // Actualizar el estado del usuario a offline\r\n        stompClient.disconnect();\r\n        window.location.href = \"/login\";  \r\n      }*/\n\n\n  return /*#__PURE__*/_jsxDEV(ChatRoomUI, {\n    userData: userData,\n    privateChats: privateChats,\n    publicChats: publicChats,\n    tab: tab,\n    setTab: handleTabChange,\n    handleMessage: handleMessage,\n    sendValue: sendValue,\n    sendPrivateValue: sendPrivateValue,\n    handleUsername: handleUsername,\n    registerUser: registerUser,\n    loginUser: loginUser,\n    unreadMessages: unreadMessages,\n    isRegistering: isRegistering,\n    setIsRegistering: setIsRegistering,\n    allUsers: allUsers,\n    searchQuery: searchQuery,\n    setSearchQuery: setSearchQuery,\n    searchUsers: searchUsers,\n    logoutUser: handleLogout\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 793,\n    columnNumber: 5\n  }, this);\n};\n\n_s(ChatRoom, \"A1PgZ30za/kCGmPHX+/L3QgZxQY=\");\n\n_c = ChatRoom;\nexport default ChatRoom;\n\nvar _c;\n\n$RefreshReg$(_c, \"ChatRoom\");","map":{"version":3,"sources":["C:/Users/USER/Documents/GitHub/Distribuidas/Distribuidas/PARCIAL II/PROYECTO/react-client/src/components/ChatRoom.js"],"names":["React","useEffect","useState","over","SockJS","ChatRoomUI","axios","DOMPurify","stompClient","ChatRoom","privateChats","setPrivateChats","Map","publicChats","setPublicChats","tab","setTab","unreadMessages","setUnreadMessages","allUsers","setAllUsers","searchQuery","setSearchQuery","userData","setUserData","username","password","email","receivername","connected","message","errors","isRegistering","setIsRegistering","connect","fetchAllUsers","loadChatHistory","loadPrivateChatHistory","receiverName","response","get","sortedMessages","data","filter","msg","trim","sort","a","b","Date","date","uniqueMessages","Array","from","map","id","values","prevChats","updatedChats","set","error","console","Sock","onConnected","onError","log","subscribe","onUserStatusUpdate","onMessageReceived","onPrivateMessage","sendOnlineStatus","isOnline","fetch","method","headers","body","JSON","stringify","then","ok","catch","updateUserStatus","post","updateUserOnlineStatus","userJoin","chatMessage","senderName","status","send","sendPrivateValue","msgs","push","searchUsers","params","query","payload","payloadData","parse","prevPublicChats","prevAllUsers","sanitizeInput","input","sanitize","currentMessages","isDuplicate","some","prevUnreadMessages","newUnreadMessages","count","online","prevUsers","user","handleTabChange","name","delete","handleSearch","event","target","value","length","err","handleMessage","sendValue","prevUserData","handleUsername","filteredValue","replace","sanitizedValue","validateEmail","re","test","String","toLowerCase","validateUsername","validateFields","registerUser","Object","keys","validateLoginFields","loginUser","login","handleLogout","disconnect","window","location","href"],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA,OAAOA,KAAP,IAAgBC,SAAhB,EAA2BC,QAA3B,QAA2C,OAA3C;AACA,SAASC,IAAT,QAAqB,SAArB;AACA,OAAOC,MAAP,MAAmB,eAAnB;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,OAAOC,SAAP,MAAsB,WAAtB;;AAEA,IAAIC,WAAW,GAAG,IAAlB;;AAEA,MAAMC,QAAQ,GAAG,MAAM;AAAA;;AACrB,QAAM,CAACC,YAAD,EAAeC,eAAf,IAAkCT,QAAQ,CAAC,IAAIU,GAAJ,EAAD,CAAhD;AACA,QAAM,CAACC,WAAD,EAAcC,cAAd,IAAgCZ,QAAQ,CAAC,EAAD,CAA9C;AACA,QAAM,CAACa,GAAD,EAAMC,MAAN,IAAgBd,QAAQ,CAAC,UAAD,CAA9B;AACA,QAAM,CAACe,cAAD,EAAiBC,iBAAjB,IAAsChB,QAAQ,CAAC,IAAIU,GAAJ,EAAD,CAApD;AACA,QAAM,CAACO,QAAD,EAAWC,WAAX,IAA0BlB,QAAQ,CAAC,EAAD,CAAxC;AACA,QAAM,CAACmB,WAAD,EAAcC,cAAd,IAAgCpB,QAAQ,CAAC,EAAD,CAA9C;AAEA,QAAM,CAACqB,QAAD,EAAWC,WAAX,IAA0BtB,QAAQ,CAAC;AACvCuB,IAAAA,QAAQ,EAAE,EAD6B;AAEvCC,IAAAA,QAAQ,EAAE,EAF6B;AAGvCC,IAAAA,KAAK,EAAE,EAHgC;AAIvCC,IAAAA,YAAY,EAAE,EAJyB;AAKvCC,IAAAA,SAAS,EAAE,KAL4B;AAMvCC,IAAAA,OAAO,EAAE,EAN8B;AAOvCC,IAAAA,MAAM,EAAE;AAP+B,GAAD,CAAxC;AASA,QAAM,CAACC,aAAD,EAAgBC,gBAAhB,IAAoC/B,QAAQ,CAAC,KAAD,CAAlD;AAEAD,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIsB,QAAQ,CAACM,SAAb,EAAwB;AACtBK,MAAAA,OAAO;AACPC,MAAAA,aAAa;AACbC,MAAAA,eAAe;AAChB;AACF,GANQ,EAMN,CAACb,QAAQ,CAACM,SAAV,CANM,CAAT;AAQA5B,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIc,GAAG,KAAK,UAAR,IAAsBQ,QAAQ,CAACM,SAAnC,EAA8C;AAC5CQ,MAAAA,sBAAsB,CAACtB,GAAD,CAAtB;AACD;AACF,GAJQ,EAIN,CAACA,GAAD,CAJM,CAAT;;AAMA,QAAMsB,sBAAsB,GAAG,MAAOC,YAAP,IAAwB;AACrD,QAAIA,YAAY,KAAKf,QAAQ,CAACE,QAA1B,IAAsCV,GAAG,KAAKuB,YAAlD,EAAgE;AAC9D;AACD;;AAED,QAAI;AACF,YAAMC,QAAQ,GAAG,MAAMjC,KAAK,CAACkC,GAAN,CAAW,qDAAoDjB,QAAQ,CAACE,QAAS,iBAAgBa,YAAa,EAA9G,CAAvB;AACA,YAAMG,cAAc,GAAGF,QAAQ,CAACG,IAAT,CACpBC,MADoB,CACbC,GAAG,IAAIA,GAAG,CAACd,OAAJ,CAAYe,IAAZ,OAAuB,EADjB,EACqB;AADrB,OAEpBC,IAFoB,CAEf,CAACC,CAAD,EAAIC,CAAJ,KAAU,IAAIC,IAAJ,CAASF,CAAC,CAACG,IAAX,IAAmB,IAAID,IAAJ,CAASD,CAAC,CAACE,IAAX,CAFd,CAAvB;AAGA,YAAMC,cAAc,GAAGC,KAAK,CAACC,IAAN,CAAW,IAAIzC,GAAJ,CAAQ6B,cAAc,CAACa,GAAf,CAAmBV,GAAG,IAAI,CAACA,GAAG,CAACW,EAAL,EAASX,GAAT,CAA1B,CAAR,EAAkDY,MAAlD,EAAX,CAAvB;AAEA7C,MAAAA,eAAe,CAAC8C,SAAS,IAAI;AAC3B,cAAMC,YAAY,GAAG,IAAI9C,GAAJ,CAAQ6C,SAAR,CAArB;AACAC,QAAAA,YAAY,CAACC,GAAb,CAAiBrB,YAAjB,EAA+Ba,cAA/B;AACA,eAAOO,YAAP;AACD,OAJc,CAAf;AAKD,KAZD,CAYE,OAAOE,KAAP,EAAc;AACdC,MAAAA,OAAO,CAACD,KAAR,CAAc,qCAAd,EAAqDA,KAArD;AACD;AACF,GApBD;;AAsBA,QAAM1B,OAAO,GAAG,MAAM;AACpB,QAAI4B,IAAI,GAAG,IAAI1D,MAAJ,CAAW,0BAAX,CAAX;AACAI,IAAAA,WAAW,GAAGL,IAAI,CAAC2D,IAAD,CAAlB;AACAtD,IAAAA,WAAW,CAAC0B,OAAZ,CAAoB;AAAET,MAAAA,QAAQ,EAAEF,QAAQ,CAACE;AAArB,KAApB,EAAqDsC,WAArD,EAAkEC,OAAlE;AACD,GAJD;;AAKA,QAAMD,WAAW,GAAG,MAAM;AAC1BF,IAAAA,OAAO,CAACI,GAAR,CAAY,wBAAZ;AACAzD,IAAAA,WAAW,CAAC0D,SAAZ,CAAsB,oBAAtB,EAA4CC,kBAA5C;AACA3D,IAAAA,WAAW,CAAC0D,SAAZ,CAAsB,kBAAtB,EAA0CE,iBAA1C;AACA5D,IAAAA,WAAW,CAAC0D,SAAZ,CAAuB,SAAQ3C,QAAQ,CAACE,QAAS,UAAjD,EAA4D4C,gBAA5D,EAJ0B,CAM1B;;AACAC,IAAAA,gBAAgB,CAAC,IAAD,CAAhB;AACD,GARC;;AAUF,QAAMA,gBAAgB,GAAIC,QAAD,IAAc;AACrCC,IAAAA,KAAK,CAAC,mBAAD,EAAsB;AACzBC,MAAAA,MAAM,EAAE,MADiB;AAEzBC,MAAAA,OAAO,EAAE;AACP,wBAAgB;AADT,OAFgB;AAKzBC,MAAAA,IAAI,EAAEC,IAAI,CAACC,SAAL,CAAe;AAAEpD,QAAAA,QAAQ,EAAEF,QAAQ,CAACE,QAArB;AAA+B8C,QAAAA;AAA/B,OAAf;AALmB,KAAtB,CAAL,CAOCO,IAPD,CAOMvC,QAAQ,IAAI;AAChB,UAAI,CAACA,QAAQ,CAACwC,EAAd,EAAkB;AAChBlB,QAAAA,OAAO,CAACD,KAAR,CAAc,8BAAd;AACD;AACF,KAXD,EAYCoB,KAZD,CAYOpB,KAAK,IAAI;AACdC,MAAAA,OAAO,CAACD,KAAR,CAAc,6BAAd,EAA6CA,KAA7C;AACD,KAdD;AAeD,GAhBD;;AAmBE,QAAMqB,gBAAgB,GAAG,OAAOxD,QAAP,EAAiB8C,QAAjB,KAA8B;AACrD,QAAI;AACF,YAAMjE,KAAK,CAAC4E,IAAN,CAAW,wCAAX,EAAqD;AAAEzD,QAAAA,QAAF;AAAY8C,QAAAA;AAAZ,OAArD,CAAN;AACAY,MAAAA,sBAAsB,CAAC1D,QAAD,EAAW8C,QAAX,CAAtB;AACD,KAHD,CAGE,OAAOX,KAAP,EAAc;AACdC,MAAAA,OAAO,CAACD,KAAR,CAAc,6BAAd,EAA6CA,KAA7C;AACD;AACF,GAPD;;AASA,QAAMwB,QAAQ,GAAG,MAAM;AACrB,QAAIC,WAAW,GAAG;AAChBC,MAAAA,UAAU,EAAE/D,QAAQ,CAACE,QADL;AAEhB8D,MAAAA,MAAM,EAAE;AAFQ,KAAlB;AAIA/E,IAAAA,WAAW,CAACgF,IAAZ,CAAiB,cAAjB,EAAiC,EAAjC,EAAqCZ,IAAI,CAACC,SAAL,CAAeQ,WAAf,CAArC;AACD,GAND;;AAQA,QAAMlD,aAAa,GAAG,YAAY;AAChC,QAAI;AACF,YAAMI,QAAQ,GAAG,MAAMjC,KAAK,CAACkC,GAAN,CAAU,qCAAV,CAAvB;AACApB,MAAAA,WAAW,CAACmB,QAAQ,CAACG,IAAV,CAAX;AACD,KAHD,CAGE,OAAOkB,KAAP,EAAc;AACdC,MAAAA,OAAO,CAACD,KAAR,CAAc,wBAAd,EAAwCA,KAAxC;AACD;AACF,GAPD;;AAQA,QAAM6B,gBAAgB,GAAG,MAAM;AAC7B,QAAIjF,WAAJ,EAAiB;AACf,UAAI6E,WAAW,GAAG;AAChBC,QAAAA,UAAU,EAAE/D,QAAQ,CAACE,QADL;AAEhBa,QAAAA,YAAY,EAAEvB,GAFE;AAGhBe,QAAAA,OAAO,EAAEP,QAAQ,CAACO,OAHF;AAIhByD,QAAAA,MAAM,EAAE;AAJQ,OAAlB;;AAOA,UAAIhE,QAAQ,CAACE,QAAT,KAAsBV,GAA1B,EAA+B;AAC7B,YAAI2E,IAAI,GAAGhF,YAAY,CAAC8B,GAAb,CAAiBzB,GAAjB,KAAyB,EAApC;AACA2E,QAAAA,IAAI,CAACC,IAAL,CAAUN,WAAV;AACA1E,QAAAA,eAAe,CAAC,IAAIC,GAAJ,CAAQF,YAAY,CAACiD,GAAb,CAAiB5C,GAAjB,EAAsB2E,IAAtB,CAAR,CAAD,CAAf;AACD;;AACDlF,MAAAA,WAAW,CAACgF,IAAZ,CAAiB,sBAAjB,EAAyC,EAAzC,EAA6CZ,IAAI,CAACC,SAAL,CAAeQ,WAAf,CAA7C;AACA7D,MAAAA,WAAW,CAAC,EAAE,GAAGD,QAAL;AAAeO,QAAAA,OAAO,EAAE;AAAxB,OAAD,CAAX;AACD;AACF,GAjBD;;AAmBA,QAAM8D,WAAW,GAAG,YAAY;AAC9B,QAAI;AACF,YAAMrD,QAAQ,GAAG,MAAMjC,KAAK,CAACkC,GAAN,CAAW,wCAAX,EAAoD;AACzEqD,QAAAA,MAAM,EAAE;AAAEC,UAAAA,KAAK,EAAEzE;AAAT;AADiE,OAApD,CAAvB;AAGAD,MAAAA,WAAW,CAACmB,QAAQ,CAACG,IAAV,CAAX;AACD,KALD,CAKE,OAAOkB,KAAP,EAAc;AACdC,MAAAA,OAAO,CAACD,KAAR,CAAc,wBAAd,EAAwCA,KAAxC;AACD;AACF,GATD;;AAWA,QAAMxB,eAAe,GAAG,YAAY;AAClC,QAAI;AACF,YAAMG,QAAQ,GAAG,MAAMjC,KAAK,CAACkC,GAAN,CAAU,yCAAV,CAAvB;AACA,YAAMC,cAAc,GAAGF,QAAQ,CAACG,IAAT,CACpBC,MADoB,CACbC,GAAG,IAAIA,GAAG,CAACd,OAAJ,IAAec,GAAG,CAACd,OAAJ,CAAYe,IAAZ,OAAuB,EADhC,EAEpBC,IAFoB,CAEf,CAACC,CAAD,EAAIC,CAAJ,KAAU,IAAIC,IAAJ,CAASF,CAAC,CAACG,IAAX,IAAmB,IAAID,IAAJ,CAASD,CAAC,CAACE,IAAX,CAFd,CAAvB;AAGApC,MAAAA,cAAc,CAAC2B,cAAD,CAAd;AACD,KAND,CAME,OAAOmB,KAAP,EAAc;AACdC,MAAAA,OAAO,CAACD,KAAR,CAAc,6BAAd,EAA6CA,KAA7C;AACD;AACF,GAVD;;AAYA,QAAMQ,iBAAiB,GAAI2B,OAAD,IAAa;AACrC,UAAMC,WAAW,GAAGpB,IAAI,CAACqB,KAAL,CAAWF,OAAO,CAACpB,IAAnB,CAApB;;AACA,YAAQqB,WAAW,CAACT,MAApB;AACE,WAAK,MAAL;AACE,YAAI,CAAC7E,YAAY,CAAC8B,GAAb,CAAiBwD,WAAW,CAACV,UAA7B,CAAL,EAA+C;AAC7C5E,UAAAA,YAAY,CAACiD,GAAb,CAAiBqC,WAAW,CAACV,UAA7B,EAAyC,EAAzC;AACA3E,UAAAA,eAAe,CAAC,IAAIC,GAAJ,CAAQF,YAAR,CAAD,CAAf;AACD;;AACDyB,QAAAA,aAAa;AACb;;AACF,WAAK,SAAL;AACE,YAAI6D,WAAW,CAAClE,OAAZ,CAAoBe,IAApB,OAA+B,EAAnC,EAAuC;AACrC/B,UAAAA,cAAc,CAACoF,eAAe,IAAI,CAAC,GAAGA,eAAJ,EAAqBF,WAArB,CAApB,CAAd;AACD;;AACD;;AACF,WAAK,UAAL;AACE7D,QAAAA,aAAa;AACb;;AACF;AACEf,QAAAA,WAAW,CAAC+E,YAAY,IAAI,CAAC,GAAGA,YAAJ,EAAkBH,WAAlB,CAAjB,CAAX;AACA;AAlBJ;AAoBD,GAtBD;;AAwBA,QAAMI,aAAa,GAAIC,KAAD,IAAW;AAC/B,WAAO9F,SAAS,CAAC+F,QAAV,CAAmBD,KAAnB,CAAP;AACD,GAFD;;AAIA,QAAMhC,gBAAgB,GAAI0B,OAAD,IAAa;AACpC,UAAMC,WAAW,GAAGpB,IAAI,CAACqB,KAAL,CAAWF,OAAO,CAACpB,IAAnB,CAApB;;AAEA,QAAIqB,WAAW,CAACV,UAAZ,KAA2B/D,QAAQ,CAACE,QAApC,IAAgDV,GAAG,KAAKQ,QAAQ,CAACE,QAArE,EAA+E;AAC7E;AACD;;AAED,QAAIuE,WAAW,CAAClE,OAAZ,CAAoBe,IAApB,OAA+B,EAAnC,EAAuC;AACrC;AACD;;AAEDlC,IAAAA,eAAe,CAAC8C,SAAS,IAAI;AAC3B,YAAMC,YAAY,GAAG,IAAI9C,GAAJ,CAAQ6C,SAAR,CAArB;AACA,YAAM8C,eAAe,GAAG7C,YAAY,CAAClB,GAAb,CAAiBwD,WAAW,CAACV,UAA7B,KAA4C,EAApE;AACA,YAAMkB,WAAW,GAAGD,eAAe,CAACE,IAAhB,CAAqB7D,GAAG,IAAIA,GAAG,CAACW,EAAJ,KAAWyC,WAAW,CAACzC,EAAnD,CAApB;;AACA,UAAI,CAACiD,WAAL,EAAkB;AAChB9C,QAAAA,YAAY,CAACC,GAAb,CAAiBqC,WAAW,CAACV,UAA7B,EAAyC,CAAC,GAAGiB,eAAJ,EAAqBP,WAArB,CAAzC;AACD;;AACD,aAAOtC,YAAP;AACD,KARc,CAAf;;AAUA,QAAI3C,GAAG,KAAKiF,WAAW,CAACV,UAAxB,EAAoC;AAClCpE,MAAAA,iBAAiB,CAACwF,kBAAkB,IAAI;AACtC,cAAMC,iBAAiB,GAAG,IAAI/F,GAAJ,CAAQ8F,kBAAR,CAA1B;AACA,cAAME,KAAK,GAAGD,iBAAiB,CAACnE,GAAlB,CAAsBwD,WAAW,CAACV,UAAlC,KAAiD,CAA/D;AACAqB,QAAAA,iBAAiB,CAAChD,GAAlB,CAAsBqC,WAAW,CAACV,UAAlC,EAA8CsB,KAAK,GAAG,CAAtD;AACA,eAAOD,iBAAP;AACD,OALgB,CAAjB;AAMD;AACF,GA7BD;;AAgCA,QAAMxB,sBAAsB,GAAG,CAAC1D,QAAD,EAAWoF,MAAX,KAAsB;AACnDzF,IAAAA,WAAW,CAAC0F,SAAS,IAAIA,SAAS,CAACxD,GAAV,CAAcyD,IAAI,IACzCA,IAAI,CAACtF,QAAL,KAAkBA,QAAlB,GAA6B,EAAE,GAAGsF,IAAL;AAAWF,MAAAA;AAAX,KAA7B,GAAmDE,IAD5B,CAAd,CAAX;AAGD,GAJD;;AAOA,QAAMC,eAAe,GAAIC,IAAD,IAAU;AAChCjG,IAAAA,MAAM,CAACiG,IAAD,CAAN;AAEA/F,IAAAA,iBAAiB,CAACwF,kBAAkB,IAAI;AACtC,YAAMC,iBAAiB,GAAG,IAAI/F,GAAJ,CAAQ8F,kBAAR,CAA1B;AACAC,MAAAA,iBAAiB,CAACO,MAAlB,CAAyBD,IAAzB;AACA,aAAON,iBAAP;AACD,KAJgB,CAAjB;;AAMA,QAAIM,IAAI,KAAK,UAAb,EAAyB;AACvB5E,MAAAA,sBAAsB,CAAC4E,IAAD,CAAtB;AACD;AACF,GAZD;;AAcA,QAAME,YAAY,GAAIC,KAAD,IAAW;AAC9B,UAAMtB,KAAK,GAAGsB,KAAK,CAACC,MAAN,CAAaC,KAA3B;AACAhG,IAAAA,cAAc,CAACwE,KAAD,CAAd;;AACA,QAAIA,KAAK,CAACyB,MAAN,GAAe,CAAnB,EAAsB;AACpB3B,MAAAA,WAAW,CAACE,KAAD,CAAX;AACD,KAFD,MAEO;AACL3D,MAAAA,aAAa;AACd;AACF,GARD;;AAUA,QAAM6B,OAAO,GAAIwD,GAAD,IAAS;AACvB3D,IAAAA,OAAO,CAACI,GAAR,CAAYuD,GAAZ;AACD,GAFD;;AAIA,QAAMC,aAAa,GAAIL,KAAD,IAAW;AAC/B,UAAM;AAAEE,MAAAA;AAAF,QAAYF,KAAK,CAACC,MAAxB;AACA7F,IAAAA,WAAW,CAAC,EAAE,GAAGD,QAAL;AAAeO,MAAAA,OAAO,EAAEwF;AAAxB,KAAD,CAAX;AACD,GAHD;;AAKE,QAAMI,SAAS,GAAG,MAAM;AACtB,QAAIlH,WAAJ,EAAiB;AACf,YAAM6E,WAAW,GAAG;AAClBC,QAAAA,UAAU,EAAE/D,QAAQ,CAACE,QADH;AAElBK,QAAAA,OAAO,EAAEP,QAAQ,CAACO,OAFA;AAGlByD,QAAAA,MAAM,EAAE;AAHU,OAApB;AAKA/E,MAAAA,WAAW,CAACgF,IAAZ,CAAiB,cAAjB,EAAiC,EAAjC,EAAqCZ,IAAI,CAACC,SAAL,CAAeQ,WAAf,CAArC;AACA7D,MAAAA,WAAW,CAACmG,YAAY,KAAK,EAAE,GAAGA,YAAL;AAAmB7F,QAAAA,OAAO,EAAE;AAA5B,OAAL,CAAb,CAAX;AACD;AACF,GAVD;;AAaF,QAAM8F,cAAc,GAAIR,KAAD,IAAW;AAChC,UAAM;AAAEH,MAAAA,IAAF;AAAQK,MAAAA;AAAR,QAAkBF,KAAK,CAACC,MAA9B;;AACA,QAAIJ,IAAI,KAAK,UAAb,EAAyB;AACvB,YAAMY,aAAa,GAAGP,KAAK,CAACQ,OAAN,CAAc,iBAAd,EAAiC,EAAjC,CAAtB;AACAtG,MAAAA,WAAW,CAAC,EAAE,GAAGD,QAAL;AAAe,SAAC0F,IAAD,GAAQY;AAAvB,OAAD,CAAX;AACD,KAHD,MAGO;AACLrG,MAAAA,WAAW,CAAC,EAAE,GAAGD,QAAL;AAAe,SAAC0F,IAAD,GAAQK;AAAvB,OAAD,CAAX;AACA,YAAMS,cAAc,GAAGxH,SAAS,CAAC+F,QAAV,CAAmBgB,KAAnB,CAAvB;AACA9F,MAAAA,WAAW,CAAC,EAAE,GAAGD,QAAL;AAAe,SAAC0F,IAAD,GAAQc;AAAvB,OAAD,CAAX;AACD;AACF,GAVD;;AAYA,QAAMC,aAAa,GAAIrG,KAAD,IAAW;AAC/B,UAAMsG,EAAE,GAAG,4BAAX;AACA,WAAOA,EAAE,CAACC,IAAH,CAAQC,MAAM,CAACxG,KAAD,CAAN,CAAcyG,WAAd,EAAR,CAAP;AACD,GAHD;;AAKA,QAAMC,gBAAgB,GAAI5G,QAAD,IAAc;AACrC,UAAMwG,EAAE,GAAG,aAAX;AACA,WAAOA,EAAE,CAACC,IAAH,CAAQzG,QAAR,CAAP;AACD,GAHD;;AAKA,QAAM6G,cAAc,GAAG,MAAM;AAC3B,UAAMvG,MAAM,GAAG,EAAf;;AACA,QAAI,CAACR,QAAQ,CAACE,QAAV,IAAsB,CAAC4G,gBAAgB,CAAC9G,QAAQ,CAACE,QAAV,CAA3C,EAAgE;AAC9DM,MAAAA,MAAM,CAACN,QAAP,GAAkB,iDAAlB;AACD;;AACD,QAAI,CAACF,QAAQ,CAACG,QAAd,EAAwB;AACtBK,MAAAA,MAAM,CAACL,QAAP,GAAkB,oCAAlB;AACD;;AACD,QAAI,CAACH,QAAQ,CAACI,KAAV,IAAmB,CAACqG,aAAa,CAACzG,QAAQ,CAACI,KAAV,CAArC,EAAuD;AACrDI,MAAAA,MAAM,CAACJ,KAAP,GAAe,uBAAf;AACD;;AACD,WAAOI,MAAP;AACD,GAZD;;AAcA,QAAMwG,YAAY,GAAG,YAAY;AAC/B,UAAMxG,MAAM,GAAGuG,cAAc,EAA7B;;AACA,QAAIE,MAAM,CAACC,IAAP,CAAY1G,MAAZ,EAAoBwF,MAApB,GAA6B,CAAjC,EAAoC;AAClC/F,MAAAA,WAAW,CAAC,EAAE,GAAGD,QAAL;AAAeQ,QAAAA;AAAf,OAAD,CAAX;AACA;AACD;;AACD,QAAI;AACF,YAAMQ,QAAQ,GAAG,MAAMjC,KAAK,CAAC4E,IAAN,CAAW,yCAAX,EAAsD;AAC3EzD,QAAAA,QAAQ,EAAEF,QAAQ,CAACE,QADwD;AAE3EC,QAAAA,QAAQ,EAAEH,QAAQ,CAACG,QAFwD;AAG3EC,QAAAA,KAAK,EAAEJ,QAAQ,CAACI;AAH2D,OAAtD,CAAvB;AAKAkC,MAAAA,OAAO,CAACI,GAAR,CAAY1B,QAAQ,CAACG,IAArB;AACAT,MAAAA,gBAAgB,CAAC,KAAD,CAAhB;AACD,KARD,CAQE,OAAO2B,KAAP,EAAc;AACdC,MAAAA,OAAO,CAACD,KAAR,CAAc,sBAAd,EAAsCA,KAAK,CAACrB,QAAN,CAAeG,IAArD;AACD;AACF,GAjBD;;AAmBA,QAAMgG,mBAAmB,GAAG,MAAM;AAChC,UAAM3G,MAAM,GAAG,EAAf;;AACA,QAAI,CAACR,QAAQ,CAACE,QAAd,EAAwB;AACtBM,MAAAA,MAAM,CAACN,QAAP,GAAkB,2CAAlB;AACD;;AACD,QAAI,CAACF,QAAQ,CAACG,QAAd,EAAwB;AACtBK,MAAAA,MAAM,CAACL,QAAP,GAAkB,oCAAlB;AACD;;AACD,WAAOK,MAAP;AACD,GATD;;AAWA,QAAM4G,SAAS,GAAG,YAAY;AAC5B,UAAM5G,MAAM,GAAG2G,mBAAmB,EAAlC;;AACA,QAAIF,MAAM,CAACC,IAAP,CAAY1G,MAAZ,EAAoBwF,MAApB,GAA6B,CAAjC,EAAoC;AAClC/F,MAAAA,WAAW,CAAC,EAAE,GAAGD,QAAL;AAAeQ,QAAAA;AAAf,OAAD,CAAX;AACA;AACD;;AACD,QAAI;AACF,YAAMQ,QAAQ,GAAG,MAAMjC,KAAK,CAAC4E,IAAN,CAAW,sCAAX,EAAmD;AACxEzD,QAAAA,QAAQ,EAAEF,QAAQ,CAACE,QADqD;AAExEC,QAAAA,QAAQ,EAAEH,QAAQ,CAACG;AAFqD,OAAnD,CAAvB;AAIAmC,MAAAA,OAAO,CAACI,GAAR,CAAY1B,QAAQ,CAACG,IAArB;AACAlB,MAAAA,WAAW,CAAC,EAAE,GAAGD,QAAL;AAAeM,QAAAA,SAAS,EAAE,IAA1B;AAAgCE,QAAAA,MAAM,EAAE;AAAxC,OAAD,CAAX;AACD,KAPD,CAOE,OAAO6B,KAAP,EAAc;AACdC,MAAAA,OAAO,CAACD,KAAR,CAAc,eAAd,EAA+BA,KAAK,CAACrB,QAAN,CAAeG,IAA9C;AACAlB,MAAAA,WAAW,CAAC,EAAE,GAAGD,QAAL;AAAeQ,QAAAA,MAAM,EAAE,EAAE,GAAGA,MAAL;AAAa6G,UAAAA,KAAK,EAAE;AAApB;AAAvB,OAAD,CAAX;AACD;AACF,GAjBD;AAkBF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,QAAMC,YAAY,GAAG,MAAM;AACzB;AACA,QAAIrI,WAAJ,EAAiB;AACfA,MAAAA,WAAW,CAACsI,UAAZ,CAAuB,MAAM;AAC3BjF,QAAAA,OAAO,CAACI,GAAR,CAAY,cAAZ,EAD2B,CAE3B;;AACA8E,QAAAA,MAAM,CAACC,QAAP,CAAgBC,IAAhB,GAAuB,QAAvB;AACD,OAJD;AAKD,KAND,MAMO;AACL;AACAF,MAAAA,MAAM,CAACC,QAAP,CAAgBC,IAAhB,GAAuB,QAAvB;AACD;AACF,GAZD;AAeA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEE,sBACE,QAAC,UAAD;AACE,IAAA,QAAQ,EAAE1H,QADZ;AAEE,IAAA,YAAY,EAAEb,YAFhB;AAGE,IAAA,WAAW,EAAEG,WAHf;AAIE,IAAA,GAAG,EAAEE,GAJP;AAKE,IAAA,MAAM,EAAEiG,eALV;AAME,IAAA,aAAa,EAAES,aANjB;AAOE,IAAA,SAAS,EAAEC,SAPb;AAQE,IAAA,gBAAgB,EAAEjC,gBARpB;AASE,IAAA,cAAc,EAAEmC,cATlB;AAUE,IAAA,YAAY,EAAEW,YAVhB;AAWE,IAAA,SAAS,EAAEI,SAXb;AAYE,IAAA,cAAc,EAAE1H,cAZlB;AAaE,IAAA,aAAa,EAAEe,aAbjB;AAcE,IAAA,gBAAgB,EAAEC,gBAdpB;AAeE,IAAA,QAAQ,EAAEd,QAfZ;AAgBE,IAAA,WAAW,EAAEE,WAhBf;AAiBE,IAAA,cAAc,EAAEC,cAjBlB;AAkBE,IAAA,WAAW,EAAEsE,WAlBf;AAmBE,IAAA,UAAU,EAAEiD;AAnBd;AAAA;AAAA;AAAA;AAAA,UADF;AAuBD,CAxZD;;GAAMpI,Q;;KAAAA,Q;AA0ZN,eAAeA,QAAf","sourcesContent":["/* \r\n//ESTE ESTA BIEN\r\n\r\nimport React, { useEffect, useState } from 'react';\r\nimport { over } from 'stompjs';\r\nimport SockJS from 'sockjs-client';\r\nimport ChatRoomUI from './ChatRoomUI';\r\nimport axios from 'axios';\r\nimport DOMPurify from 'dompurify';\r\n\r\nlet stompClient = null;\r\n\r\nconst ChatRoom = () => {\r\n  const [privateChats, setPrivateChats] = useState(new Map());\r\n  const [publicChats, setPublicChats] = useState([]);\r\n  const [tab, setTab] = useState(\"CHATROOM\");\r\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\r\n  const [allUsers, setAllUsers] = useState([]);\r\n  const [searchQuery, setSearchQuery] = useState('');\r\n\r\n  const [userData, setUserData] = useState({\r\n    username: '',\r\n    password: '',\r\n    email: '',\r\n    receivername: '',\r\n    connected: false,\r\n    message: '',\r\n    errors: {}\r\n  });\r\n  const [isRegistering, setIsRegistering] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (userData.connected) {\r\n      connect();\r\n      fetchAllUsers();\r\n      loadChatHistory();\r\n    }\r\n  }, [userData.connected]);\r\n\r\n  useEffect(() => {\r\n    if (tab !== \"CHATROOM\" && userData.connected) {\r\n      loadPrivateChatHistory(tab);\r\n    }\r\n  }, [tab]);\r\n\r\n  const loadPrivateChatHistory = async (receiverName) => {\r\n    if (receiverName === userData.username && tab === receiverName) {\r\n      return;\r\n    }\r\n  \r\n    try {\r\n      const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=${receiverName}`);\r\n      const sortedMessages = response.data\r\n        .filter(msg => msg.message.trim() !== '') // Filtrar mensajes vacíos\r\n        .sort((a, b) => new Date(a.date) - new Date(b.date));\r\n      const uniqueMessages = Array.from(new Map(sortedMessages.map(msg => [msg.id, msg])).values());\r\n  \r\n      setPrivateChats(prevChats => {\r\n        const updatedChats = new Map(prevChats);\r\n        updatedChats.set(receiverName, uniqueMessages);\r\n        return updatedChats;\r\n      });\r\n    } catch (error) {\r\n      console.error('Error loading private chat history:', error);\r\n    }\r\n  };\r\n\r\n  const connect = () => {\r\n    let Sock = new SockJS('http://localhost:8080/ws');\r\n    stompClient = over(Sock);\r\n    stompClient.connect({ username: userData.username }, onConnected, onError);\r\n  }\r\n\r\n  const onConnected = () => {\r\n    setUserData({ ...userData, connected: true });\r\n    stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n    stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n    userJoin();\r\n    fetchAllUsers();\r\n    loadChatHistory();\r\n  }\r\n\r\n  const userJoin = () => {\r\n    var chatMessage = {\r\n      senderName: userData.username,\r\n      status: \"JOIN\"\r\n    };\r\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n  }\r\n\r\n  const fetchAllUsers = async () => {\r\n    try {\r\n      const response = await axios.get('http://localhost:8080/api/users/all');\r\n      setAllUsers(response.data);\r\n    } catch (error) {\r\n      console.error('Failed to fetch users:', error);\r\n    }\r\n  };\r\n\r\n  const sendPrivateValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        receiverName: tab,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n\r\n      if (userData.username !== tab) {\r\n        let msgs = privateChats.get(tab) || [];\r\n        msgs.push(chatMessage);\r\n        setPrivateChats(new Map(privateChats.set(tab, msgs)));\r\n      }\r\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const searchUsers = async () => {\r\n    try {\r\n      const response = await axios.get(`http://localhost:8080/api/users/search`, {\r\n        params: { query: searchQuery }\r\n      });\r\n      setAllUsers(response.data);\r\n    } catch (error) {\r\n      console.error('Error searching users:', error);\r\n    }\r\n  };\r\n\r\n  const loadChatHistory = async () => {\r\n    try {\r\n      const response = await axios.get('http://localhost:8080/api/chats/history');\r\n      const sortedMessages = response.data\r\n        .filter(msg => msg.message && msg.message.trim() !== '') \r\n        .sort((a, b) => new Date(a.date) - new Date(b.date));\r\n      setPublicChats(sortedMessages);\r\n    } catch (error) {\r\n      console.error('Error loading chat history:', error);\r\n    }\r\n  };\r\n  \r\n  const onMessageReceived = (payload) => {\r\n    const payloadData = JSON.parse(payload.body);\r\n    switch (payloadData.status) {\r\n      case \"JOIN\":\r\n        if (!privateChats.get(payloadData.senderName)) {\r\n          privateChats.set(payloadData.senderName, []);\r\n          setPrivateChats(new Map(privateChats));\r\n        }\r\n        fetchAllUsers();\r\n        break;\r\n      case \"MESSAGE\":\r\n        if (payloadData.message.trim() !== '') { \r\n          setPublicChats(prevPublicChats => [...prevPublicChats, payloadData]);\r\n        }\r\n        break;\r\n      case \"NEW_USER\":\r\n        fetchAllUsers();\r\n        break;\r\n      default:\r\n        setAllUsers(prevAllUsers => [...prevAllUsers, payloadData]);\r\n        break;\r\n    }\r\n  };\r\n  \r\n  \r\n\r\n  const sanitizeInput = (input) => {\r\n    return DOMPurify.sanitize(input);\r\n  };\r\n\r\n  const onPrivateMessage = (payload) => {\r\n    const payloadData = JSON.parse(payload.body);\r\n  \r\n    if (payloadData.senderName === userData.username && tab === userData.username) {\r\n      return;\r\n    }\r\n  \r\n    if (payloadData.message.trim() === '') { \r\n      return;\r\n    }\r\n  \r\n    setPrivateChats(prevChats => {\r\n      const updatedChats = new Map(prevChats);\r\n      const currentMessages = updatedChats.get(payloadData.senderName) || [];\r\n      const isDuplicate = currentMessages.some(msg => msg.id === payloadData.id);\r\n      if (!isDuplicate) {\r\n        updatedChats.set(payloadData.senderName, [...currentMessages, payloadData]);\r\n      }\r\n      return updatedChats;\r\n    });\r\n  \r\n    if (tab !== payloadData.senderName) {\r\n      setUnreadMessages(prevUnreadMessages => {\r\n        const newUnreadMessages = new Map(prevUnreadMessages);\r\n        const count = newUnreadMessages.get(payloadData.senderName) || 0;\r\n        newUnreadMessages.set(payloadData.senderName, count + 1);\r\n        return newUnreadMessages;\r\n      });\r\n    }\r\n  };\r\n  \r\n  const updateUserOnlineStatus = (username, online) => {\r\n    setAllUsers(prevUsers => prevUsers.map(user =>\r\n      user.username === username ? { ...user, online } : user\r\n    ));\r\n  };\r\n\r\n  const renderUserStatus = (user) => {\r\n    return user.online ? (\r\n      <span style={{ color: 'green' }}>Online</span>\r\n    ) : (\r\n      <span style={{ color: 'red' }}>Offline</span>\r\n    );\r\n  };\r\n\r\n  const renderUserList = () => {\r\n    return allUsers.map(user => (\r\n      <div key={user.username} style={{ margin: '10px 0' }}>\r\n        <span>{user.username}</span> {renderUserStatus(user)}\r\n      </div>\r\n    ));\r\n  };\r\n\r\n  const handleTabChange = (name) => {\r\n    setTab(name);\r\n\r\n    setUnreadMessages(prevUnreadMessages => {\r\n      const newUnreadMessages = new Map(prevUnreadMessages);\r\n      newUnreadMessages.delete(name);\r\n      return newUnreadMessages;\r\n    });\r\n\r\n    if (name !== \"CHATROOM\") {\r\n      loadPrivateChatHistory(name);\r\n    }\r\n  };\r\n\r\n  const handleSearch = (event) => {\r\n    const query = event.target.value;\r\n    setSearchQuery(query);\r\n    if (query.length > 0) {\r\n      searchUsers(query);\r\n    } else {\r\n      fetchAllUsers();\r\n    }\r\n  };\r\n\r\n  const onError = (err) => {\r\n    console.log(err);\r\n  }\r\n\r\n  const handleMessage = (event) => {\r\n    const { value } = event.target;\r\n    setUserData({ ...userData, message: value });\r\n  }\r\n\r\n    const sendValue = () => {\r\n      if (stompClient) {\r\n        const chatMessage = {\r\n          senderName: userData.username,\r\n          message: userData.message,\r\n          status: \"MESSAGE\"\r\n        };\r\n        stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n        setUserData(prevUserData => ({ ...prevUserData, message: \"\" }));\r\n      }\r\n    };\r\n    \r\n\r\n  const handleUsername = (event) => {\r\n    const { name, value } = event.target;\r\n    if (name === \"username\") {\r\n      const filteredValue = value.replace(/[^a-zA-Z0-9\\s]/g, '');\r\n      setUserData({ ...userData, [name]: filteredValue });\r\n    } else {\r\n      setUserData({ ...userData, [name]: value });\r\n      const sanitizedValue = DOMPurify.sanitize(value);\r\n      setUserData({ ...userData, [name]: sanitizedValue });\r\n    }\r\n  };\r\n\r\n  const validateEmail = (email) => {\r\n    const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n    return re.test(String(email).toLowerCase());\r\n  };\r\n\r\n  const validateUsername = (username) => {\r\n    const re = /^[a-zA-Z]+$/;\r\n    return re.test(username);\r\n  };\r\n\r\n  const validateFields = () => {\r\n    const errors = {};\r\n    if (!userData.username || !validateUsername(userData.username)) {\r\n      errors.username = \"El nombre de usuario solo puede contener letras\";\r\n    }\r\n    if (!userData.password) {\r\n      errors.password = \"La contraseña no puede estar vacía\";\r\n    }\r\n    if (!userData.email || !validateEmail(userData.email)) {\r\n      errors.email = \"El email no es válido\";\r\n    }\r\n    return errors;\r\n  };\r\n\r\n  const registerUser = async () => {\r\n    const errors = validateFields();\r\n    if (Object.keys(errors).length > 0) {\r\n      setUserData({ ...userData, errors });\r\n      return;\r\n    }\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/register', {\r\n        username: userData.username,\r\n        password: userData.password,\r\n        email: userData.email\r\n      });\r\n      console.log(response.data);\r\n      setIsRegistering(false);\r\n    } catch (error) {\r\n      console.error('Registration failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  const validateLoginFields = () => {\r\n    const errors = {};\r\n    if (!userData.username) {\r\n      errors.username = \"El nombre de usuario no puede estar vacío\";\r\n    }\r\n    if (!userData.password) {\r\n      errors.password = \"La contraseña no puede estar vacía\";\r\n    }\r\n    return errors;\r\n  };\r\n  \r\n  const loginUser = async () => {\r\n    const errors = validateLoginFields();\r\n    if (Object.keys(errors).length > 0) {\r\n      setUserData({ ...userData, errors });\r\n      return;\r\n    }\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/login', {\r\n        username: userData.username,\r\n        password: userData.password\r\n      });\r\n      console.log(response.data);\r\n      setUserData({ ...userData, connected: true, errors: {} });\r\n    } catch (error) {\r\n      console.error('Login failed:', error.response.data);\r\n      setUserData({ ...userData, errors: { ...errors, login: 'Nombre de usuario o contraseña incorrectos' } });\r\n    }\r\n  };\r\n\r\n  const handleLogout = () => {\r\n    setUserData({ ...userData, connected: false });\r\n    stompClient.disconnect();\r\n    window.location.href = \"/login\";  \r\n  }\r\n  \r\n  return (\r\n    <ChatRoomUI\r\n      userData={userData}\r\n      privateChats={privateChats}\r\n      publicChats={publicChats}\r\n      tab={tab}\r\n      setTab={handleTabChange}\r\n      handleMessage={handleMessage}\r\n      sendValue={sendValue}\r\n      sendPrivateValue={sendPrivateValue}\r\n      handleUsername={handleUsername}\r\n      registerUser={registerUser}\r\n      loginUser={loginUser}\r\n      unreadMessages={unreadMessages}\r\n      isRegistering={isRegistering}\r\n      setIsRegistering={setIsRegistering}\r\n      allUsers={allUsers}\r\n      searchQuery={searchQuery}\r\n      setSearchQuery={setSearchQuery}\r\n      searchUsers={searchUsers}\r\n      renderUserStatus={searchUsers}\r\n      renderUserList={searchUsers}\r\n      logoutUser={handleLogout}\r\n    />\r\n  );\r\n}\r\n\r\nexport default ChatRoom;\r\n\r\n\r\n\r\n*/\r\n\r\n\r\n\r\n\r\nimport React, { useEffect, useState } from 'react';\r\nimport { over } from 'stompjs';\r\nimport SockJS from 'sockjs-client';\r\nimport ChatRoomUI from './ChatRoomUI';\r\nimport axios from 'axios';\r\nimport DOMPurify from 'dompurify';\r\n\r\nlet stompClient = null;\r\n\r\nconst ChatRoom = () => {\r\n  const [privateChats, setPrivateChats] = useState(new Map());\r\n  const [publicChats, setPublicChats] = useState([]);\r\n  const [tab, setTab] = useState(\"CHATROOM\");\r\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\r\n  const [allUsers, setAllUsers] = useState([]);\r\n  const [searchQuery, setSearchQuery] = useState('');\r\n\r\n  const [userData, setUserData] = useState({\r\n    username: '',\r\n    password: '',\r\n    email: '',\r\n    receivername: '',\r\n    connected: false,\r\n    message: '',\r\n    errors: {}\r\n  });\r\n  const [isRegistering, setIsRegistering] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (userData.connected) {\r\n      connect();\r\n      fetchAllUsers();\r\n      loadChatHistory();\r\n    }\r\n  }, [userData.connected]);\r\n\r\n  useEffect(() => {\r\n    if (tab !== \"CHATROOM\" && userData.connected) {\r\n      loadPrivateChatHistory(tab);\r\n    }\r\n  }, [tab]);\r\n\r\n  const loadPrivateChatHistory = async (receiverName) => {\r\n    if (receiverName === userData.username && tab === receiverName) {\r\n      return;\r\n    }\r\n  \r\n    try {\r\n      const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=${receiverName}`);\r\n      const sortedMessages = response.data\r\n        .filter(msg => msg.message.trim() !== '') // Filtrar mensajes vacíos\r\n        .sort((a, b) => new Date(a.date) - new Date(b.date));\r\n      const uniqueMessages = Array.from(new Map(sortedMessages.map(msg => [msg.id, msg])).values());\r\n  \r\n      setPrivateChats(prevChats => {\r\n        const updatedChats = new Map(prevChats);\r\n        updatedChats.set(receiverName, uniqueMessages);\r\n        return updatedChats;\r\n      });\r\n    } catch (error) {\r\n      console.error('Error loading private chat history:', error);\r\n    }\r\n  };\r\n\r\n  const connect = () => {\r\n    let Sock = new SockJS('http://localhost:8080/ws');\r\n    stompClient = over(Sock);\r\n    stompClient.connect({ username: userData.username }, onConnected, onError);\r\n  }\r\n  const onConnected = () => {\r\n  console.log('Connected to WebSocket');\r\n  stompClient.subscribe('/topic/user-status', onUserStatusUpdate);\r\n  stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n  stompClient.subscribe(`/user/${userData.username}/private`, onPrivateMessage);\r\n\r\n  // Opcional: Envía un mensaje al servidor para confirmar que el usuario está en línea\r\n  sendOnlineStatus(true);\r\n};\r\n\r\nconst sendOnlineStatus = (isOnline) => {\r\n  fetch('/api/users/status', {\r\n    method: 'POST',\r\n    headers: {\r\n      'Content-Type': 'application/json'\r\n    },\r\n    body: JSON.stringify({ username: userData.username, isOnline })\r\n  })\r\n  .then(response => {\r\n    if (!response.ok) {\r\n      console.error('Failed to update user status');\r\n    }\r\n  })\r\n  .catch(error => {\r\n    console.error('Error updating user status:', error);\r\n  });\r\n};\r\n\r\n\r\n  const updateUserStatus = async (username, isOnline) => {\r\n    try {\r\n      await axios.post('http://localhost:8080/api/users/status', { username, isOnline });\r\n      updateUserOnlineStatus(username, isOnline);\r\n    } catch (error) {\r\n      console.error('Error updating user status:', error);\r\n    }\r\n  };\r\n\r\n  const userJoin = () => {\r\n    var chatMessage = {\r\n      senderName: userData.username,\r\n      status: \"JOIN\"\r\n    };\r\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n  }\r\n\r\n  const fetchAllUsers = async () => {\r\n    try {\r\n      const response = await axios.get('http://localhost:8080/api/users/all');\r\n      setAllUsers(response.data);\r\n    } catch (error) {\r\n      console.error('Failed to fetch users:', error);\r\n    }\r\n  };\r\n  const sendPrivateValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        receiverName: tab,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n\r\n      if (userData.username !== tab) {\r\n        let msgs = privateChats.get(tab) || [];\r\n        msgs.push(chatMessage);\r\n        setPrivateChats(new Map(privateChats.set(tab, msgs)));\r\n      }\r\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const searchUsers = async () => {\r\n    try {\r\n      const response = await axios.get(`http://localhost:8080/api/users/search`, {\r\n        params: { query: searchQuery }\r\n      });\r\n      setAllUsers(response.data);\r\n    } catch (error) {\r\n      console.error('Error searching users:', error);\r\n    }\r\n  };\r\n\r\n  const loadChatHistory = async () => {\r\n    try {\r\n      const response = await axios.get('http://localhost:8080/api/chats/history');\r\n      const sortedMessages = response.data\r\n        .filter(msg => msg.message && msg.message.trim() !== '') \r\n        .sort((a, b) => new Date(a.date) - new Date(b.date));\r\n      setPublicChats(sortedMessages);\r\n    } catch (error) {\r\n      console.error('Error loading chat history:', error);\r\n    }\r\n  };\r\n  \r\n  const onMessageReceived = (payload) => {\r\n    const payloadData = JSON.parse(payload.body);\r\n    switch (payloadData.status) {\r\n      case \"JOIN\":\r\n        if (!privateChats.get(payloadData.senderName)) {\r\n          privateChats.set(payloadData.senderName, []);\r\n          setPrivateChats(new Map(privateChats));\r\n        }\r\n        fetchAllUsers();\r\n        break;\r\n      case \"MESSAGE\":\r\n        if (payloadData.message.trim() !== '') { \r\n          setPublicChats(prevPublicChats => [...prevPublicChats, payloadData]);\r\n        }\r\n        break;\r\n      case \"NEW_USER\":\r\n        fetchAllUsers();\r\n        break;\r\n      default:\r\n        setAllUsers(prevAllUsers => [...prevAllUsers, payloadData]);\r\n        break;\r\n    }\r\n  };\r\n \r\n  const sanitizeInput = (input) => {\r\n    return DOMPurify.sanitize(input);\r\n  };\r\n\r\n  const onPrivateMessage = (payload) => {\r\n    const payloadData = JSON.parse(payload.body);\r\n  \r\n    if (payloadData.senderName === userData.username && tab === userData.username) {\r\n      return;\r\n    }\r\n  \r\n    if (payloadData.message.trim() === '') { \r\n      return;\r\n    }\r\n  \r\n    setPrivateChats(prevChats => {\r\n      const updatedChats = new Map(prevChats);\r\n      const currentMessages = updatedChats.get(payloadData.senderName) || [];\r\n      const isDuplicate = currentMessages.some(msg => msg.id === payloadData.id);\r\n      if (!isDuplicate) {\r\n        updatedChats.set(payloadData.senderName, [...currentMessages, payloadData]);\r\n      }\r\n      return updatedChats;\r\n    });\r\n  \r\n    if (tab !== payloadData.senderName) {\r\n      setUnreadMessages(prevUnreadMessages => {\r\n        const newUnreadMessages = new Map(prevUnreadMessages);\r\n        const count = newUnreadMessages.get(payloadData.senderName) || 0;\r\n        newUnreadMessages.set(payloadData.senderName, count + 1);\r\n        return newUnreadMessages;\r\n      });\r\n    }\r\n  };\r\n  \r\n\r\n  const updateUserOnlineStatus = (username, online) => {\r\n    setAllUsers(prevUsers => prevUsers.map(user =>\r\n      user.username === username ? { ...user, online } : user\r\n    ));\r\n  };\r\n\r\n\r\n  const handleTabChange = (name) => {\r\n    setTab(name);\r\n\r\n    setUnreadMessages(prevUnreadMessages => {\r\n      const newUnreadMessages = new Map(prevUnreadMessages);\r\n      newUnreadMessages.delete(name);\r\n      return newUnreadMessages;\r\n    });\r\n\r\n    if (name !== \"CHATROOM\") {\r\n      loadPrivateChatHistory(name);\r\n    }\r\n  };\r\n\r\n  const handleSearch = (event) => {\r\n    const query = event.target.value;\r\n    setSearchQuery(query);\r\n    if (query.length > 0) {\r\n      searchUsers(query);\r\n    } else {\r\n      fetchAllUsers();\r\n    }\r\n  };\r\n\r\n  const onError = (err) => {\r\n    console.log(err);\r\n  }\r\n\r\n  const handleMessage = (event) => {\r\n    const { value } = event.target;\r\n    setUserData({ ...userData, message: value });\r\n  }\r\n\r\n    const sendValue = () => {\r\n      if (stompClient) {\r\n        const chatMessage = {\r\n          senderName: userData.username,\r\n          message: userData.message,\r\n          status: \"MESSAGE\"\r\n        };\r\n        stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n        setUserData(prevUserData => ({ ...prevUserData, message: \"\" }));\r\n      }\r\n    };\r\n    \r\n\r\n  const handleUsername = (event) => {\r\n    const { name, value } = event.target;\r\n    if (name === \"username\") {\r\n      const filteredValue = value.replace(/[^a-zA-Z0-9\\s]/g, '');\r\n      setUserData({ ...userData, [name]: filteredValue });\r\n    } else {\r\n      setUserData({ ...userData, [name]: value });\r\n      const sanitizedValue = DOMPurify.sanitize(value);\r\n      setUserData({ ...userData, [name]: sanitizedValue });\r\n    }\r\n  };\r\n\r\n  const validateEmail = (email) => {\r\n    const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n    return re.test(String(email).toLowerCase());\r\n  };\r\n\r\n  const validateUsername = (username) => {\r\n    const re = /^[a-zA-Z]+$/;\r\n    return re.test(username);\r\n  };\r\n\r\n  const validateFields = () => {\r\n    const errors = {};\r\n    if (!userData.username || !validateUsername(userData.username)) {\r\n      errors.username = \"El nombre de usuario solo puede contener letras\";\r\n    }\r\n    if (!userData.password) {\r\n      errors.password = \"La contraseña no puede estar vacía\";\r\n    }\r\n    if (!userData.email || !validateEmail(userData.email)) {\r\n      errors.email = \"El email no es válido\";\r\n    }\r\n    return errors;\r\n  };\r\n\r\n  const registerUser = async () => {\r\n    const errors = validateFields();\r\n    if (Object.keys(errors).length > 0) {\r\n      setUserData({ ...userData, errors });\r\n      return;\r\n    }\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/register', {\r\n        username: userData.username,\r\n        password: userData.password,\r\n        email: userData.email\r\n      });\r\n      console.log(response.data);\r\n      setIsRegistering(false);\r\n    } catch (error) {\r\n      console.error('Registration failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  const validateLoginFields = () => {\r\n    const errors = {};\r\n    if (!userData.username) {\r\n      errors.username = \"El nombre de usuario no puede estar vacío\";\r\n    }\r\n    if (!userData.password) {\r\n      errors.password = \"La contraseña no puede estar vacía\";\r\n    }\r\n    return errors;\r\n  };\r\n  \r\n  const loginUser = async () => {\r\n    const errors = validateLoginFields();\r\n    if (Object.keys(errors).length > 0) {\r\n      setUserData({ ...userData, errors });\r\n      return;\r\n    }\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/login', {\r\n        username: userData.username,\r\n        password: userData.password\r\n      });\r\n      console.log(response.data);\r\n      setUserData({ ...userData, connected: true, errors: {} });\r\n    } catch (error) {\r\n      console.error('Login failed:', error.response.data);\r\n      setUserData({ ...userData, errors: { ...errors, login: 'Nombre de usuario o contraseña incorrectos' } });\r\n    }\r\n  };\r\n/*\r\n  const handleLogout = () => {\r\n    updateUserStatus(userData.username, false);\r\n    setUserData({ ...userData, connected: false });\r\n    stompClient.disconnect(() => {\r\n      window.location.href = \"/login\";\r\n    });\r\n  };*/\r\n  const handleLogout = () => {\r\n    // Desconectar el cliente STOMP\r\n    if (stompClient) {\r\n      stompClient.disconnect(() => {\r\n        console.log('Disconnected');\r\n        // Redirige al usuario a la página de inicio de sesión después de desconectar\r\n        window.location.href = '/login';\r\n      });\r\n    } else {\r\n      // Redirige al usuario a la página de inicio de sesión si no hay cliente STOMP\r\n      window.location.href = '/login';\r\n    }\r\n  };\r\n  \r\n\r\n  /*\r\n      const handleLogout = () => {\r\n        updateUserStatus(userData.username, false);\r\n        setUserData({ ...userData, connected: false });\r\n        updateUserOnlineStatus(userData.username, false); // Actualizar el estado del usuario a offline\r\n        stompClient.disconnect();\r\n        window.location.href = \"/login\";  \r\n      }*/\r\n  \r\n  return (\r\n    <ChatRoomUI\r\n      userData={userData}\r\n      privateChats={privateChats}\r\n      publicChats={publicChats}\r\n      tab={tab}\r\n      setTab={handleTabChange}\r\n      handleMessage={handleMessage}\r\n      sendValue={sendValue}\r\n      sendPrivateValue={sendPrivateValue}\r\n      handleUsername={handleUsername}\r\n      registerUser={registerUser}\r\n      loginUser={loginUser}\r\n      unreadMessages={unreadMessages}\r\n      isRegistering={isRegistering}\r\n      setIsRegistering={setIsRegistering}\r\n      allUsers={allUsers}\r\n      searchQuery={searchQuery}\r\n      setSearchQuery={setSearchQuery}\r\n      searchUsers={searchUsers}\r\n      logoutUser={handleLogout}\r\n    />\r\n  );\r\n}\r\n\r\nexport default ChatRoom;\r\n"]},"metadata":{},"sourceType":"module"}