{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\USER\\\\Documents\\\\GitHub\\\\Distribuidas\\\\Distribuidas\\\\PARCIAL II\\\\PROYECTO\\\\react-client\\\\src\\\\components\\\\ChatRoom.js\",\n    _s = $RefreshSig$();\n\n/* \r\n//ESTE ESTA BIEN\r\n\r\nimport React, { useEffect, useState } from 'react';\r\nimport { over } from 'stompjs';\r\nimport SockJS from 'sockjs-client';\r\nimport ChatRoomUI from './ChatRoomUI';\r\nimport axios from 'axios';\r\nimport DOMPurify from 'dompurify';\r\n\r\nlet stompClient = null;\r\n\r\nconst ChatRoom = () => {\r\n  const [privateChats, setPrivateChats] = useState(new Map());\r\n  const [publicChats, setPublicChats] = useState([]);\r\n  const [tab, setTab] = useState(\"CHATROOM\");\r\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\r\n  const [allUsers, setAllUsers] = useState([]);\r\n  const [searchQuery, setSearchQuery] = useState('');\r\n\r\n  const [userData, setUserData] = useState({\r\n    username: '',\r\n    password: '',\r\n    email: '',\r\n    receivername: '',\r\n    connected: false,\r\n    message: '',\r\n    errors: {}\r\n  });\r\n  const [isRegistering, setIsRegistering] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (userData.connected) {\r\n      connect();\r\n      fetchAllUsers();\r\n      loadChatHistory();\r\n    }\r\n  }, [userData.connected]);\r\n\r\n  useEffect(() => {\r\n    if (tab !== \"CHATROOM\" && userData.connected) {\r\n      loadPrivateChatHistory(tab);\r\n    }\r\n  }, [tab]);\r\n\r\n  const loadPrivateChatHistory = async (receiverName) => {\r\n    if (receiverName === userData.username && tab === receiverName) {\r\n      return;\r\n    }\r\n  \r\n    try {\r\n      const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=${receiverName}`);\r\n      const sortedMessages = response.data\r\n        .filter(msg => msg.message.trim() !== '') // Filtrar mensajes vacíos\r\n        .sort((a, b) => new Date(a.date) - new Date(b.date));\r\n      const uniqueMessages = Array.from(new Map(sortedMessages.map(msg => [msg.id, msg])).values());\r\n  \r\n      setPrivateChats(prevChats => {\r\n        const updatedChats = new Map(prevChats);\r\n        updatedChats.set(receiverName, uniqueMessages);\r\n        return updatedChats;\r\n      });\r\n    } catch (error) {\r\n      console.error('Error loading private chat history:', error);\r\n    }\r\n  };\r\n\r\n  const connect = () => {\r\n    let Sock = new SockJS('http://localhost:8080/ws');\r\n    stompClient = over(Sock);\r\n    stompClient.connect({ username: userData.username }, onConnected, onError);\r\n  }\r\n\r\n  const onConnected = () => {\r\n    setUserData({ ...userData, connected: true });\r\n    stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n    stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n    userJoin();\r\n    fetchAllUsers();\r\n    loadChatHistory();\r\n  }\r\n\r\n  const userJoin = () => {\r\n    var chatMessage = {\r\n      senderName: userData.username,\r\n      status: \"JOIN\"\r\n    };\r\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n  }\r\n\r\n  const fetchAllUsers = async () => {\r\n    try {\r\n      const response = await axios.get('http://localhost:8080/api/users/all');\r\n      setAllUsers(response.data);\r\n    } catch (error) {\r\n      console.error('Failed to fetch users:', error);\r\n    }\r\n  };\r\n\r\n  const sendPrivateValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        receiverName: tab,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n\r\n      if (userData.username !== tab) {\r\n        let msgs = privateChats.get(tab) || [];\r\n        msgs.push(chatMessage);\r\n        setPrivateChats(new Map(privateChats.set(tab, msgs)));\r\n      }\r\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const searchUsers = async () => {\r\n    try {\r\n      const response = await axios.get(`http://localhost:8080/api/users/search`, {\r\n        params: { query: searchQuery }\r\n      });\r\n      setAllUsers(response.data);\r\n    } catch (error) {\r\n      console.error('Error searching users:', error);\r\n    }\r\n  };\r\n\r\n  const loadChatHistory = async () => {\r\n    try {\r\n      const response = await axios.get('http://localhost:8080/api/chats/history');\r\n      const sortedMessages = response.data\r\n        .filter(msg => msg.message && msg.message.trim() !== '') \r\n        .sort((a, b) => new Date(a.date) - new Date(b.date));\r\n      setPublicChats(sortedMessages);\r\n    } catch (error) {\r\n      console.error('Error loading chat history:', error);\r\n    }\r\n  };\r\n  \r\n  const onMessageReceived = (payload) => {\r\n    const payloadData = JSON.parse(payload.body);\r\n    switch (payloadData.status) {\r\n      case \"JOIN\":\r\n        if (!privateChats.get(payloadData.senderName)) {\r\n          privateChats.set(payloadData.senderName, []);\r\n          setPrivateChats(new Map(privateChats));\r\n        }\r\n        fetchAllUsers();\r\n        break;\r\n      case \"MESSAGE\":\r\n        if (payloadData.message.trim() !== '') { \r\n          setPublicChats(prevPublicChats => [...prevPublicChats, payloadData]);\r\n        }\r\n        break;\r\n      case \"NEW_USER\":\r\n        fetchAllUsers();\r\n        break;\r\n      default:\r\n        setAllUsers(prevAllUsers => [...prevAllUsers, payloadData]);\r\n        break;\r\n    }\r\n  };\r\n  \r\n  \r\n\r\n  const sanitizeInput = (input) => {\r\n    return DOMPurify.sanitize(input);\r\n  };\r\n\r\n  const onPrivateMessage = (payload) => {\r\n    const payloadData = JSON.parse(payload.body);\r\n  \r\n    if (payloadData.senderName === userData.username && tab === userData.username) {\r\n      return;\r\n    }\r\n  \r\n    if (payloadData.message.trim() === '') { \r\n      return;\r\n    }\r\n  \r\n    setPrivateChats(prevChats => {\r\n      const updatedChats = new Map(prevChats);\r\n      const currentMessages = updatedChats.get(payloadData.senderName) || [];\r\n      const isDuplicate = currentMessages.some(msg => msg.id === payloadData.id);\r\n      if (!isDuplicate) {\r\n        updatedChats.set(payloadData.senderName, [...currentMessages, payloadData]);\r\n      }\r\n      return updatedChats;\r\n    });\r\n  \r\n    if (tab !== payloadData.senderName) {\r\n      setUnreadMessages(prevUnreadMessages => {\r\n        const newUnreadMessages = new Map(prevUnreadMessages);\r\n        const count = newUnreadMessages.get(payloadData.senderName) || 0;\r\n        newUnreadMessages.set(payloadData.senderName, count + 1);\r\n        return newUnreadMessages;\r\n      });\r\n    }\r\n  };\r\n  \r\n  const updateUserOnlineStatus = (username, online) => {\r\n    setAllUsers(prevUsers => prevUsers.map(user =>\r\n      user.username === username ? { ...user, online } : user\r\n    ));\r\n  };\r\n\r\n  const renderUserStatus = (user) => {\r\n    return user.online ? (\r\n      <span style={{ color: 'green' }}>Online</span>\r\n    ) : (\r\n      <span style={{ color: 'red' }}>Offline</span>\r\n    );\r\n  };\r\n\r\n  const renderUserList = () => {\r\n    return allUsers.map(user => (\r\n      <div key={user.username} style={{ margin: '10px 0' }}>\r\n        <span>{user.username}</span> {renderUserStatus(user)}\r\n      </div>\r\n    ));\r\n  };\r\n\r\n  const handleTabChange = (name) => {\r\n    setTab(name);\r\n\r\n    setUnreadMessages(prevUnreadMessages => {\r\n      const newUnreadMessages = new Map(prevUnreadMessages);\r\n      newUnreadMessages.delete(name);\r\n      return newUnreadMessages;\r\n    });\r\n\r\n    if (name !== \"CHATROOM\") {\r\n      loadPrivateChatHistory(name);\r\n    }\r\n  };\r\n\r\n  const handleSearch = (event) => {\r\n    const query = event.target.value;\r\n    setSearchQuery(query);\r\n    if (query.length > 0) {\r\n      searchUsers(query);\r\n    } else {\r\n      fetchAllUsers();\r\n    }\r\n  };\r\n\r\n  const onError = (err) => {\r\n    console.log(err);\r\n  }\r\n\r\n  const handleMessage = (event) => {\r\n    const { value } = event.target;\r\n    setUserData({ ...userData, message: value });\r\n  }\r\n\r\n    const sendValue = () => {\r\n      if (stompClient) {\r\n        const chatMessage = {\r\n          senderName: userData.username,\r\n          message: userData.message,\r\n          status: \"MESSAGE\"\r\n        };\r\n        stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n        setUserData(prevUserData => ({ ...prevUserData, message: \"\" }));\r\n      }\r\n    };\r\n    \r\n\r\n  const handleUsername = (event) => {\r\n    const { name, value } = event.target;\r\n    if (name === \"username\") {\r\n      const filteredValue = value.replace(/[^a-zA-Z0-9\\s]/g, '');\r\n      setUserData({ ...userData, [name]: filteredValue });\r\n    } else {\r\n      setUserData({ ...userData, [name]: value });\r\n      const sanitizedValue = DOMPurify.sanitize(value);\r\n      setUserData({ ...userData, [name]: sanitizedValue });\r\n    }\r\n  };\r\n\r\n  const validateEmail = (email) => {\r\n    const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n    return re.test(String(email).toLowerCase());\r\n  };\r\n\r\n  const validateUsername = (username) => {\r\n    const re = /^[a-zA-Z]+$/;\r\n    return re.test(username);\r\n  };\r\n\r\n  const validateFields = () => {\r\n    const errors = {};\r\n    if (!userData.username || !validateUsername(userData.username)) {\r\n      errors.username = \"El nombre de usuario solo puede contener letras\";\r\n    }\r\n    if (!userData.password) {\r\n      errors.password = \"La contraseña no puede estar vacía\";\r\n    }\r\n    if (!userData.email || !validateEmail(userData.email)) {\r\n      errors.email = \"El email no es válido\";\r\n    }\r\n    return errors;\r\n  };\r\n\r\n  const registerUser = async () => {\r\n    const errors = validateFields();\r\n    if (Object.keys(errors).length > 0) {\r\n      setUserData({ ...userData, errors });\r\n      return;\r\n    }\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/register', {\r\n        username: userData.username,\r\n        password: userData.password,\r\n        email: userData.email\r\n      });\r\n      console.log(response.data);\r\n      setIsRegistering(false);\r\n    } catch (error) {\r\n      console.error('Registration failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  const validateLoginFields = () => {\r\n    const errors = {};\r\n    if (!userData.username) {\r\n      errors.username = \"El nombre de usuario no puede estar vacío\";\r\n    }\r\n    if (!userData.password) {\r\n      errors.password = \"La contraseña no puede estar vacía\";\r\n    }\r\n    return errors;\r\n  };\r\n  \r\n  const loginUser = async () => {\r\n    const errors = validateLoginFields();\r\n    if (Object.keys(errors).length > 0) {\r\n      setUserData({ ...userData, errors });\r\n      return;\r\n    }\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/login', {\r\n        username: userData.username,\r\n        password: userData.password\r\n      });\r\n      console.log(response.data);\r\n      setUserData({ ...userData, connected: true, errors: {} });\r\n    } catch (error) {\r\n      console.error('Login failed:', error.response.data);\r\n      setUserData({ ...userData, errors: { ...errors, login: 'Nombre de usuario o contraseña incorrectos' } });\r\n    }\r\n  };\r\n\r\n  const handleLogout = () => {\r\n    setUserData({ ...userData, connected: false });\r\n    stompClient.disconnect();\r\n    window.location.href = \"/login\";  \r\n  }\r\n  \r\n  return (\r\n    <ChatRoomUI\r\n      userData={userData}\r\n      privateChats={privateChats}\r\n      publicChats={publicChats}\r\n      tab={tab}\r\n      setTab={handleTabChange}\r\n      handleMessage={handleMessage}\r\n      sendValue={sendValue}\r\n      sendPrivateValue={sendPrivateValue}\r\n      handleUsername={handleUsername}\r\n      registerUser={registerUser}\r\n      loginUser={loginUser}\r\n      unreadMessages={unreadMessages}\r\n      isRegistering={isRegistering}\r\n      setIsRegistering={setIsRegistering}\r\n      allUsers={allUsers}\r\n      searchQuery={searchQuery}\r\n      setSearchQuery={setSearchQuery}\r\n      searchUsers={searchUsers}\r\n      renderUserStatus={searchUsers}\r\n      renderUserList={searchUsers}\r\n      logoutUser={handleLogout}\r\n    />\r\n  );\r\n}\r\n\r\nexport default ChatRoom;\r\n\r\n\r\n*/\nimport React, { useEffect, useState } from 'react';\nimport { over } from 'stompjs';\nimport SockJS from 'sockjs-client';\nimport ChatRoomUI from './ChatRoomUI';\nimport axios from 'axios';\nimport DOMPurify from 'dompurify';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet stompClient = null;\n\nconst ChatRoom = () => {\n  _s();\n\n  const [privateChats, setPrivateChats] = useState(new Map());\n  const [publicChats, setPublicChats] = useState([]);\n  const [tab, setTab] = useState(\"CHATROOM\");\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\n  const [allUsers, setAllUsers] = useState([]);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [userData, setUserData] = useState({\n    username: '',\n    password: '',\n    email: '',\n    receivername: '',\n    connected: false,\n    message: '',\n    errors: {}\n  });\n  const [isRegistering, setIsRegistering] = useState(false);\n  useEffect(() => {\n    if (userData.connected) {\n      connect();\n      fetchAllUsers();\n      loadChatHistory();\n    }\n  }, [userData.connected]);\n  useEffect(() => {\n    if (userData.connected && !publicChats.length) {\n      loadChatHistory();\n    }\n  }, [userData.connected]);\n  useEffect(() => {\n    if (tab !== \"CHATROOM\" && userData.connected) {\n      loadPrivateChatHistory(tab);\n    }\n  }, [tab]);\n  useEffect(() => {\n    window.addEventListener('beforeunload', () => {\n      if (userData.connected) {\n        stompClient.disconnect(() => {\n          axios.post(\"/api/users/disconnect\", {\n            username: userData.username\n          });\n        });\n      }\n    });\n  }, [userData.connected]);\n  useEffect(() => {\n    window.addEventListener('unload', () => {\n      if (userData.connected) {\n        stompClient.disconnect(() => {\n          axios.post(\"/api/users/disconnect\", {\n            username: userData.username\n          });\n        });\n      }\n    });\n  }, [userData.connected]);\n  useEffect(() => {\n    window.addEventListener('pagehide', () => {\n      if (userData.connected) {\n        stompClient.disconnect(() => {\n          axios.post(\"/api/users/disconnect\", {\n            username: userData.username\n          });\n        });\n      }\n    });\n  }, [userData.connected]);\n\n  const loadPrivateChatHistory = async receiverName => {\n    try {\n      const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=${receiverName}`);\n      const sortedMessages = response.data.filter(msg => msg.message.trim() !== '').sort((a, b) => new Date(a.date) - new Date(b.date));\n      setPrivateChats(prevChats => {\n        const updatedChats = new Map(prevChats);\n        const currentMessages = updatedChats.get(receiverName) || [];\n        const newMessages = sortedMessages.filter(msg => !currentMessages.find(m => m.id === msg.id));\n        updatedChats.set(receiverName, [...currentMessages, ...newMessages]);\n        return updatedChats;\n      });\n    } catch (error) {\n      console.error('Error loading private chat history:', error);\n    }\n  };\n\n  const connect = () => {\n    let Sock = new SockJS('http://localhost:8080/ws');\n    stompClient = over(Sock);\n    stompClient.connect({\n      username: userData.username\n    }, onConnected, onError);\n  };\n\n  const onConnected = () => {\n    setUserData({ ...userData,\n      connected: true\n    });\n    stompClient.subscribe('/chatroom/public', onMessageReceived);\n    stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\n    userJoin();\n    fetchAllUsers();\n    loadChatHistory();\n    updateUserStatus(userData.username, true);\n  };\n\n  const updateUserStatus = async (username, isOnline) => {\n    try {\n      await axios.post('http://localhost:8080/api/users/status', {\n        username,\n        isOnline\n      });\n      setAllUsers(prevUsers => prevUsers.map(user => user.username === username ? { ...user,\n        online: isOnline\n      } : user));\n    } catch (error) {\n      console.error('Error updating user status:', error);\n    }\n  };\n\n  const userJoin = () => {\n    var chatMessage = {\n      senderName: userData.username,\n      status: \"JOIN\"\n    };\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\n  };\n\n  const fetchAllUsers = async () => {\n    try {\n      const response = await axios.get('http://localhost:8080/api/users/all');\n      setAllUsers(response.data.map(user => ({ ...user,\n        isConnected: user.online\n      })));\n    } catch (error) {\n      console.error('Failed to fetch users:', error);\n    }\n  };\n\n  const sendPrivateValue = () => {\n    if (stompClient) {\n      var chatMessage = {\n        senderName: userData.username,\n        receiverName: tab,\n        message: userData.message,\n        status: \"MESSAGE\"\n      };\n\n      if (userData.username !== tab) {\n        let msgs = privateChats.get(tab) || [];\n        msgs.push(chatMessage);\n        setPrivateChats(new Map(privateChats.set(tab, msgs)));\n      }\n\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\n      setUserData({ ...userData,\n        message: \"\"\n      });\n    }\n  };\n\n  const searchUsers = async () => {\n    try {\n      const response = await axios.get(`http://localhost:8080/api/users/search`, {\n        params: {\n          query: searchQuery\n        }\n      });\n      setAllUsers(response.data);\n    } catch (error) {\n      console.error('Error searching users:', error);\n    }\n  };\n\n  const loadChatHistory = async () => {\n    if (!userData.connected) {\n      return;\n    }\n\n    try {\n      const response = await axios.get('http://localhost:8080/api/chats/history');\n      const sortedMessages = response.data.filter(msg => msg.message !== null && msg.message.trim() !== '').sort((a, b) => new Date(a.date) - new Date(b.date));\n      setPublicChats(sortedMessages);\n    } catch (error) {\n      console.error('Error loading chat history:', error);\n    }\n  };\n\n  const onMessageReceived = payload => {\n    const payloadData = JSON.parse(payload.body);\n\n    switch (payloadData.status) {\n      case \"USER_DISCONNECTED\":\n        setAllUsers(prevUsers => prevUsers.map(user => {\n          if (user.username === payloadData.username) {\n            return { ...user,\n              isConnected: false\n            };\n          }\n\n          return user;\n        }));\n        break;\n\n      case \"JOIN\":\n        if (!privateChats.get(payloadData.senderName)) {\n          privateChats.set(payloadData.senderName, []);\n          setPrivateChats(new Map(privateChats));\n        }\n\n        fetchAllUsers();\n        break;\n\n      case \"MESSAGE\":\n        if (payloadData.message.trim() !== '') {\n          if (payloadData.receiverName === \"CHATROOM\" && payloadData.senderName !== userData.username) {\n            if (!publicChats.find(msg => msg.id === payloadData.id)) {\n              setPublicChats(prevPublicChats => [...prevPublicChats, payloadData]);\n            }\n          }\n        }\n\n        break;\n\n      case \"NEW_USER\":\n        fetchAllUsers();\n        break;\n\n      default:\n        setAllUsers(prevAllUsers => [...prevAllUsers, payloadData]);\n        break;\n    }\n  };\n\n  const sanitizeInput = input => {\n    return DOMPurify.sanitize(input);\n  };\n\n  const onPrivateMessage = payload => {\n    const payloadData = JSON.parse(payload.body);\n\n    if (payloadData.senderName === userData.username && tab === userData.username) {\n      return;\n    }\n\n    if (payloadData.message.trim() === '') {\n      return;\n    }\n\n    setPrivateChats(prevChats => {\n      const updatedChats = new Map(prevChats);\n      const currentMessages = updatedChats.get(payloadData.senderName) || [];\n      const isDuplicate = currentMessages.some(msg => msg.id === payloadData.id);\n\n      if (!isDuplicate) {\n        updatedChats.set(payloadData.senderName, [...currentMessages, payloadData]);\n      }\n\n      return updatedChats;\n    });\n\n    if (tab !== payloadData.senderName) {\n      setUnreadMessages(prevUnreadMessages => {\n        const newUnreadMessages = new Map(prevUnreadMessages);\n        const count = newUnreadMessages.get(payloadData.senderName) || 0;\n        newUnreadMessages.set(payloadData.senderName, count + 1);\n        return newUnreadMessages;\n      });\n    }\n  };\n\n  const updateUserOnlineStatus = (username, online) => {\n    setAllUsers(prevUsers => prevUsers.map(user => user.username === username ? { ...user,\n      online\n    } : user));\n  };\n\n  const onError = err => {\n    console.log(err);\n  };\n\n  const handleLogin = async event => {\n    event.preventDefault();\n\n    try {\n      const response = await axios.post('http://localhost:8080/api/users/login', {\n        username: userData.username,\n        password: userData.password\n      });\n\n      if (response.data.success) {\n        setUserData({ ...userData,\n          connected: true\n        });\n      } else {\n        setUserData({ ...userData,\n          errors: response.data.errors\n        });\n      }\n    } catch (error) {\n      console.error('Error during login:', error);\n    }\n  };\n\n  const handleRegister = async event => {\n    event.preventDefault();\n\n    try {\n      const response = await axios.post('http://localhost:8080/api/users/register', {\n        username: userData.username,\n        password: userData.password,\n        email: userData.email\n      });\n\n      if (response.data.success) {\n        setIsRegistering(false);\n      } else {\n        setUserData({ ...userData,\n          errors: response.data.errors\n        });\n      }\n    } catch (error) {\n      console.error('Error during registration:', error);\n    }\n  };\n\n  const registerUser = () => {\n    setIsRegistering(true);\n  };\n\n  const loginUser = () => {\n    setIsRegistering(false);\n  };\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"container\",\n    children: !userData.connected ? /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"login-register-form\",\n      children: isRegistering ? /*#__PURE__*/_jsxDEV(\"form\", {\n        onSubmit: handleRegister,\n        children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n          children: \"Register\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 710,\n          columnNumber: 15\n        }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"text\",\n          name: \"username\",\n          placeholder: \"Enter your username\",\n          value: sanitizeInput(userData.username),\n          onChange: e => setUserData({ ...userData,\n            username: e.target.value\n          }),\n          required: true\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 711,\n          columnNumber: 15\n        }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"email\",\n          name: \"email\",\n          placeholder: \"Enter your email\",\n          value: sanitizeInput(userData.email),\n          onChange: e => setUserData({ ...userData,\n            email: e.target.value\n          }),\n          required: true\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 719,\n          columnNumber: 15\n        }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"password\",\n          name: \"password\",\n          placeholder: \"Enter your password\",\n          value: sanitizeInput(userData.password),\n          onChange: e => setUserData({ ...userData,\n            password: e.target.value\n          }),\n          required: true\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 727,\n          columnNumber: 15\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          type: \"submit\",\n          children: \"Register\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 735,\n          columnNumber: 15\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          type: \"button\",\n          onClick: loginUser,\n          children: \"Back to Login\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 736,\n          columnNumber: 15\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 709,\n        columnNumber: 13\n      }, this) : /*#__PURE__*/_jsxDEV(\"form\", {\n        onSubmit: handleLogin,\n        children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n          children: \"Login\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 740,\n          columnNumber: 15\n        }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"text\",\n          name: \"username\",\n          placeholder: \"Enter your username\",\n          value: sanitizeInput(userData.username),\n          onChange: e => setUserData({ ...userData,\n            username: e.target.value\n          }),\n          required: true\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 741,\n          columnNumber: 15\n        }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"password\",\n          name: \"password\",\n          placeholder: \"Enter your password\",\n          value: sanitizeInput(userData.password),\n          onChange: e => setUserData({ ...userData,\n            password: e.target.value\n          }),\n          required: true\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 749,\n          columnNumber: 15\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          type: \"submit\",\n          children: \"Login\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 757,\n          columnNumber: 15\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          type: \"button\",\n          onClick: registerUser,\n          children: \"Register\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 758,\n          columnNumber: 15\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 739,\n        columnNumber: 13\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 707,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(ChatRoomUI, {\n      userData: userData,\n      publicChats: publicChats,\n      privateChats: privateChats,\n      tab: tab,\n      unreadMessages: unreadMessages,\n      allUsers: allUsers,\n      searchQuery: searchQuery,\n      setTab: setTab,\n      setUserData: setUserData,\n      sendPrivateValue: sendPrivateValue,\n      setSearchQuery: setSearchQuery,\n      searchUsers: searchUsers\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 763,\n      columnNumber: 9\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 705,\n    columnNumber: 5\n  }, this);\n};\n\n_s(ChatRoom, \"5Cj2MNVUxmm0k++HF48KtnHVLRU=\");\n\n_c = ChatRoom;\nexport default ChatRoom;\n\nvar _c;\n\n$RefreshReg$(_c, \"ChatRoom\");","map":{"version":3,"sources":["C:/Users/USER/Documents/GitHub/Distribuidas/Distribuidas/PARCIAL II/PROYECTO/react-client/src/components/ChatRoom.js"],"names":["React","useEffect","useState","over","SockJS","ChatRoomUI","axios","DOMPurify","stompClient","ChatRoom","privateChats","setPrivateChats","Map","publicChats","setPublicChats","tab","setTab","unreadMessages","setUnreadMessages","allUsers","setAllUsers","searchQuery","setSearchQuery","userData","setUserData","username","password","email","receivername","connected","message","errors","isRegistering","setIsRegistering","connect","fetchAllUsers","loadChatHistory","length","loadPrivateChatHistory","window","addEventListener","disconnect","post","receiverName","response","get","sortedMessages","data","filter","msg","trim","sort","a","b","Date","date","prevChats","updatedChats","currentMessages","newMessages","find","m","id","set","error","console","Sock","onConnected","onError","subscribe","onMessageReceived","onPrivateMessage","userJoin","updateUserStatus","isOnline","prevUsers","map","user","online","chatMessage","senderName","status","send","JSON","stringify","isConnected","sendPrivateValue","msgs","push","searchUsers","params","query","payload","payloadData","parse","body","prevPublicChats","prevAllUsers","sanitizeInput","input","sanitize","isDuplicate","some","prevUnreadMessages","newUnreadMessages","count","updateUserOnlineStatus","err","log","handleLogin","event","preventDefault","success","handleRegister","registerUser","loginUser","e","target","value"],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAOA,KAAP,IAAgBC,SAAhB,EAA2BC,QAA3B,QAA2C,OAA3C;AACA,SAASC,IAAT,QAAqB,SAArB;AACA,OAAOC,MAAP,MAAmB,eAAnB;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,OAAOC,SAAP,MAAsB,WAAtB;;AAEA,IAAIC,WAAW,GAAG,IAAlB;;AAEA,MAAMC,QAAQ,GAAG,MAAM;AAAA;;AACrB,QAAM,CAACC,YAAD,EAAeC,eAAf,IAAkCT,QAAQ,CAAC,IAAIU,GAAJ,EAAD,CAAhD;AACA,QAAM,CAACC,WAAD,EAAcC,cAAd,IAAgCZ,QAAQ,CAAC,EAAD,CAA9C;AACA,QAAM,CAACa,GAAD,EAAMC,MAAN,IAAgBd,QAAQ,CAAC,U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","sourcesContent":["/* \r\n//ESTE ESTA BIEN\r\n\r\nimport React, { useEffect, useState } from 'react';\r\nimport { over } from 'stompjs';\r\nimport SockJS from 'sockjs-client';\r\nimport ChatRoomUI from './ChatRoomUI';\r\nimport axios from 'axios';\r\nimport DOMPurify from 'dompurify';\r\n\r\nlet stompClient = null;\r\n\r\nconst ChatRoom = () => {\r\n  const [privateChats, setPrivateChats] = useState(new Map());\r\n  const [publicChats, setPublicChats] = useState([]);\r\n  const [tab, setTab] = useState(\"CHATROOM\");\r\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\r\n  const [allUsers, setAllUsers] = useState([]);\r\n  const [searchQuery, setSearchQuery] = useState('');\r\n\r\n  const [userData, setUserData] = useState({\r\n    username: '',\r\n    password: '',\r\n    email: '',\r\n    receivername: '',\r\n    connected: false,\r\n    message: '',\r\n    errors: {}\r\n  });\r\n  const [isRegistering, setIsRegistering] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (userData.connected) {\r\n      connect();\r\n      fetchAllUsers();\r\n      loadChatHistory();\r\n    }\r\n  }, [userData.connected]);\r\n\r\n  useEffect(() => {\r\n    if (tab !== \"CHATROOM\" && userData.connected) {\r\n      loadPrivateChatHistory(tab);\r\n    }\r\n  }, [tab]);\r\n\r\n  const loadPrivateChatHistory = async (receiverName) => {\r\n    if (receiverName === userData.username && tab === receiverName) {\r\n      return;\r\n    }\r\n  \r\n    try {\r\n      const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=${receiverName}`);\r\n      const sortedMessages = response.data\r\n        .filter(msg => msg.message.trim() !== '') // Filtrar mensajes vacíos\r\n        .sort((a, b) => new Date(a.date) - new Date(b.date));\r\n      const uniqueMessages = Array.from(new Map(sortedMessages.map(msg => [msg.id, msg])).values());\r\n  \r\n      setPrivateChats(prevChats => {\r\n        const updatedChats = new Map(prevChats);\r\n        updatedChats.set(receiverName, uniqueMessages);\r\n        return updatedChats;\r\n      });\r\n    } catch (error) {\r\n      console.error('Error loading private chat history:', error);\r\n    }\r\n  };\r\n\r\n  const connect = () => {\r\n    let Sock = new SockJS('http://localhost:8080/ws');\r\n    stompClient = over(Sock);\r\n    stompClient.connect({ username: userData.username }, onConnected, onError);\r\n  }\r\n\r\n  const onConnected = () => {\r\n    setUserData({ ...userData, connected: true });\r\n    stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n    stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n    userJoin();\r\n    fetchAllUsers();\r\n    loadChatHistory();\r\n  }\r\n\r\n  const userJoin = () => {\r\n    var chatMessage = {\r\n      senderName: userData.username,\r\n      status: \"JOIN\"\r\n    };\r\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n  }\r\n\r\n  const fetchAllUsers = async () => {\r\n    try {\r\n      const response = await axios.get('http://localhost:8080/api/users/all');\r\n      setAllUsers(response.data);\r\n    } catch (error) {\r\n      console.error('Failed to fetch users:', error);\r\n    }\r\n  };\r\n\r\n  const sendPrivateValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        receiverName: tab,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n\r\n      if (userData.username !== tab) {\r\n        let msgs = privateChats.get(tab) || [];\r\n        msgs.push(chatMessage);\r\n        setPrivateChats(new Map(privateChats.set(tab, msgs)));\r\n      }\r\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const searchUsers = async () => {\r\n    try {\r\n      const response = await axios.get(`http://localhost:8080/api/users/search`, {\r\n        params: { query: searchQuery }\r\n      });\r\n      setAllUsers(response.data);\r\n    } catch (error) {\r\n      console.error('Error searching users:', error);\r\n    }\r\n  };\r\n\r\n  const loadChatHistory = async () => {\r\n    try {\r\n      const response = await axios.get('http://localhost:8080/api/chats/history');\r\n      const sortedMessages = response.data\r\n        .filter(msg => msg.message && msg.message.trim() !== '') \r\n        .sort((a, b) => new Date(a.date) - new Date(b.date));\r\n      setPublicChats(sortedMessages);\r\n    } catch (error) {\r\n      console.error('Error loading chat history:', error);\r\n    }\r\n  };\r\n  \r\n  const onMessageReceived = (payload) => {\r\n    const payloadData = JSON.parse(payload.body);\r\n    switch (payloadData.status) {\r\n      case \"JOIN\":\r\n        if (!privateChats.get(payloadData.senderName)) {\r\n          privateChats.set(payloadData.senderName, []);\r\n          setPrivateChats(new Map(privateChats));\r\n        }\r\n        fetchAllUsers();\r\n        break;\r\n      case \"MESSAGE\":\r\n        if (payloadData.message.trim() !== '') { \r\n          setPublicChats(prevPublicChats => [...prevPublicChats, payloadData]);\r\n        }\r\n        break;\r\n      case \"NEW_USER\":\r\n        fetchAllUsers();\r\n        break;\r\n      default:\r\n        setAllUsers(prevAllUsers => [...prevAllUsers, payloadData]);\r\n        break;\r\n    }\r\n  };\r\n  \r\n  \r\n\r\n  const sanitizeInput = (input) => {\r\n    return DOMPurify.sanitize(input);\r\n  };\r\n\r\n  const onPrivateMessage = (payload) => {\r\n    const payloadData = JSON.parse(payload.body);\r\n  \r\n    if (payloadData.senderName === userData.username && tab === userData.username) {\r\n      return;\r\n    }\r\n  \r\n    if (payloadData.message.trim() === '') { \r\n      return;\r\n    }\r\n  \r\n    setPrivateChats(prevChats => {\r\n      const updatedChats = new Map(prevChats);\r\n      const currentMessages = updatedChats.get(payloadData.senderName) || [];\r\n      const isDuplicate = currentMessages.some(msg => msg.id === payloadData.id);\r\n      if (!isDuplicate) {\r\n        updatedChats.set(payloadData.senderName, [...currentMessages, payloadData]);\r\n      }\r\n      return updatedChats;\r\n    });\r\n  \r\n    if (tab !== payloadData.senderName) {\r\n      setUnreadMessages(prevUnreadMessages => {\r\n        const newUnreadMessages = new Map(prevUnreadMessages);\r\n        const count = newUnreadMessages.get(payloadData.senderName) || 0;\r\n        newUnreadMessages.set(payloadData.senderName, count + 1);\r\n        return newUnreadMessages;\r\n      });\r\n    }\r\n  };\r\n  \r\n  const updateUserOnlineStatus = (username, online) => {\r\n    setAllUsers(prevUsers => prevUsers.map(user =>\r\n      user.username === username ? { ...user, online } : user\r\n    ));\r\n  };\r\n\r\n  const renderUserStatus = (user) => {\r\n    return user.online ? (\r\n      <span style={{ color: 'green' }}>Online</span>\r\n    ) : (\r\n      <span style={{ color: 'red' }}>Offline</span>\r\n    );\r\n  };\r\n\r\n  const renderUserList = () => {\r\n    return allUsers.map(user => (\r\n      <div key={user.username} style={{ margin: '10px 0' }}>\r\n        <span>{user.username}</span> {renderUserStatus(user)}\r\n      </div>\r\n    ));\r\n  };\r\n\r\n  const handleTabChange = (name) => {\r\n    setTab(name);\r\n\r\n    setUnreadMessages(prevUnreadMessages => {\r\n      const newUnreadMessages = new Map(prevUnreadMessages);\r\n      newUnreadMessages.delete(name);\r\n      return newUnreadMessages;\r\n    });\r\n\r\n    if (name !== \"CHATROOM\") {\r\n      loadPrivateChatHistory(name);\r\n    }\r\n  };\r\n\r\n  const handleSearch = (event) => {\r\n    const query = event.target.value;\r\n    setSearchQuery(query);\r\n    if (query.length > 0) {\r\n      searchUsers(query);\r\n    } else {\r\n      fetchAllUsers();\r\n    }\r\n  };\r\n\r\n  const onError = (err) => {\r\n    console.log(err);\r\n  }\r\n\r\n  const handleMessage = (event) => {\r\n    const { value } = event.target;\r\n    setUserData({ ...userData, message: value });\r\n  }\r\n\r\n    const sendValue = () => {\r\n      if (stompClient) {\r\n        const chatMessage = {\r\n          senderName: userData.username,\r\n          message: userData.message,\r\n          status: \"MESSAGE\"\r\n        };\r\n        stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n        setUserData(prevUserData => ({ ...prevUserData, message: \"\" }));\r\n      }\r\n    };\r\n    \r\n\r\n  const handleUsername = (event) => {\r\n    const { name, value } = event.target;\r\n    if (name === \"username\") {\r\n      const filteredValue = value.replace(/[^a-zA-Z0-9\\s]/g, '');\r\n      setUserData({ ...userData, [name]: filteredValue });\r\n    } else {\r\n      setUserData({ ...userData, [name]: value });\r\n      const sanitizedValue = DOMPurify.sanitize(value);\r\n      setUserData({ ...userData, [name]: sanitizedValue });\r\n    }\r\n  };\r\n\r\n  const validateEmail = (email) => {\r\n    const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n    return re.test(String(email).toLowerCase());\r\n  };\r\n\r\n  const validateUsername = (username) => {\r\n    const re = /^[a-zA-Z]+$/;\r\n    return re.test(username);\r\n  };\r\n\r\n  const validateFields = () => {\r\n    const errors = {};\r\n    if (!userData.username || !validateUsername(userData.username)) {\r\n      errors.username = \"El nombre de usuario solo puede contener letras\";\r\n    }\r\n    if (!userData.password) {\r\n      errors.password = \"La contraseña no puede estar vacía\";\r\n    }\r\n    if (!userData.email || !validateEmail(userData.email)) {\r\n      errors.email = \"El email no es válido\";\r\n    }\r\n    return errors;\r\n  };\r\n\r\n  const registerUser = async () => {\r\n    const errors = validateFields();\r\n    if (Object.keys(errors).length > 0) {\r\n      setUserData({ ...userData, errors });\r\n      return;\r\n    }\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/register', {\r\n        username: userData.username,\r\n        password: userData.password,\r\n        email: userData.email\r\n      });\r\n      console.log(response.data);\r\n      setIsRegistering(false);\r\n    } catch (error) {\r\n      console.error('Registration failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  const validateLoginFields = () => {\r\n    const errors = {};\r\n    if (!userData.username) {\r\n      errors.username = \"El nombre de usuario no puede estar vacío\";\r\n    }\r\n    if (!userData.password) {\r\n      errors.password = \"La contraseña no puede estar vacía\";\r\n    }\r\n    return errors;\r\n  };\r\n  \r\n  const loginUser = async () => {\r\n    const errors = validateLoginFields();\r\n    if (Object.keys(errors).length > 0) {\r\n      setUserData({ ...userData, errors });\r\n      return;\r\n    }\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/login', {\r\n        username: userData.username,\r\n        password: userData.password\r\n      });\r\n      console.log(response.data);\r\n      setUserData({ ...userData, connected: true, errors: {} });\r\n    } catch (error) {\r\n      console.error('Login failed:', error.response.data);\r\n      setUserData({ ...userData, errors: { ...errors, login: 'Nombre de usuario o contraseña incorrectos' } });\r\n    }\r\n  };\r\n\r\n  const handleLogout = () => {\r\n    setUserData({ ...userData, connected: false });\r\n    stompClient.disconnect();\r\n    window.location.href = \"/login\";  \r\n  }\r\n  \r\n  return (\r\n    <ChatRoomUI\r\n      userData={userData}\r\n      privateChats={privateChats}\r\n      publicChats={publicChats}\r\n      tab={tab}\r\n      setTab={handleTabChange}\r\n      handleMessage={handleMessage}\r\n      sendValue={sendValue}\r\n      sendPrivateValue={sendPrivateValue}\r\n      handleUsername={handleUsername}\r\n      registerUser={registerUser}\r\n      loginUser={loginUser}\r\n      unreadMessages={unreadMessages}\r\n      isRegistering={isRegistering}\r\n      setIsRegistering={setIsRegistering}\r\n      allUsers={allUsers}\r\n      searchQuery={searchQuery}\r\n      setSearchQuery={setSearchQuery}\r\n      searchUsers={searchUsers}\r\n      renderUserStatus={searchUsers}\r\n      renderUserList={searchUsers}\r\n      logoutUser={handleLogout}\r\n    />\r\n  );\r\n}\r\n\r\nexport default ChatRoom;\r\n\r\n\r\n*/\r\n\r\nimport React, { useEffect, useState } from 'react';\r\nimport { over } from 'stompjs';\r\nimport SockJS from 'sockjs-client';\r\nimport ChatRoomUI from './ChatRoomUI';\r\nimport axios from 'axios';\r\nimport DOMPurify from 'dompurify';\r\n\r\nlet stompClient = null;\r\n\r\nconst ChatRoom = () => {\r\n  const [privateChats, setPrivateChats] = useState(new Map());\r\n  const [publicChats, setPublicChats] = useState([]);\r\n  const [tab, setTab] = useState(\"CHATROOM\");\r\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\r\n  const [allUsers, setAllUsers] = useState([]);\r\n  const [searchQuery, setSearchQuery] = useState('');\r\n\r\n  const [userData, setUserData] = useState({\r\n    username: '',\r\n    password: '',\r\n    email: '',\r\n    receivername: '',\r\n    connected: false,\r\n    message: '',\r\n    errors: {}\r\n  });\r\n  const [isRegistering, setIsRegistering] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (userData.connected) {\r\n      connect();\r\n      fetchAllUsers();\r\n      loadChatHistory();\r\n    }\r\n  }, [userData.connected]);\r\n\r\n  useEffect(() => {\r\n    if (userData.connected && !publicChats.length) {\r\n      loadChatHistory();\r\n    }\r\n  }, [userData.connected]);\r\n\r\n  useEffect(() => {\r\n    if (tab !== \"CHATROOM\" && userData.connected) {\r\n      loadPrivateChatHistory(tab);\r\n    }\r\n  }, [tab]);\r\n\r\n  useEffect(() => {\r\n    window.addEventListener('beforeunload', () => {\r\n      if (userData.connected) {\r\n        stompClient.disconnect(() => {\r\n          axios.post(\"/api/users/disconnect\", { username: userData.username });\r\n        });\r\n      }\r\n    });\r\n  }, [userData.connected]);\r\n\r\n  useEffect(() => {\r\n    window.addEventListener('unload', () => {\r\n      if (userData.connected) {\r\n        stompClient.disconnect(() => {\r\n          axios.post(\"/api/users/disconnect\", { username: userData.username });\r\n        });\r\n      }\r\n    });\r\n  }, [userData.connected]);\r\n\r\n  useEffect(() => {\r\n    window.addEventListener('pagehide', () => {\r\n      if (userData.connected) {\r\n        stompClient.disconnect(() => {\r\n          axios.post(\"/api/users/disconnect\", { username: userData.username });\r\n        });\r\n      }\r\n    });\r\n  }, [userData.connected]);\r\n\r\n  const loadPrivateChatHistory = async (receiverName) => {\r\n    try {\r\n      const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=${receiverName}`);\r\n      const sortedMessages = response.data\r\n        .filter(msg => msg.message.trim() !== '')\r\n        .sort((a, b) => new Date(a.date) - new Date(b.date));\r\n\r\n      setPrivateChats(prevChats => {\r\n        const updatedChats = new Map(prevChats);\r\n        const currentMessages = updatedChats.get(receiverName) || [];\r\n        const newMessages = sortedMessages.filter(msg => !currentMessages.find(m => m.id === msg.id));\r\n        updatedChats.set(receiverName, [...currentMessages, ...newMessages]);\r\n        return updatedChats;\r\n      });\r\n    } catch (error) {\r\n      console.error('Error loading private chat history:', error);\r\n    }\r\n  };\r\n\r\n  const connect = () => {\r\n    let Sock = new SockJS('http://localhost:8080/ws');\r\n    stompClient = over(Sock);\r\n    stompClient.connect({ username: userData.username }, onConnected, onError);\r\n  }\r\n\r\n  const onConnected = () => {\r\n    setUserData({ ...userData, connected: true });\r\n    stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n    stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n    userJoin();\r\n    fetchAllUsers();\r\n    loadChatHistory();\r\n    updateUserStatus(userData.username, true);\r\n  }\r\n\r\n  const updateUserStatus = async (username, isOnline) => {\r\n    try {\r\n      await axios.post('http://localhost:8080/api/users/status', { username, isOnline });\r\n      setAllUsers(prevUsers => prevUsers.map(user =>\r\n        user.username === username ? { ...user, online: isOnline } : user\r\n      ));\r\n    } catch (error) {\r\n      console.error('Error updating user status:', error);\r\n    }\r\n  };\r\n\r\n  const userJoin = () => {\r\n    var chatMessage = {\r\n      senderName: userData.username,\r\n      status: \"JOIN\"\r\n    };\r\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n  }\r\n\r\n  const fetchAllUsers = async () => {\r\n    try {\r\n      const response = await axios.get('http://localhost:8080/api/users/all');\r\n      setAllUsers(response.data.map((user) => ({ ...user, isConnected: user.online })));\r\n    } catch (error) {\r\n      console.error('Failed to fetch users:', error);\r\n    }\r\n  };\r\n\r\n  const sendPrivateValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        receiverName: tab,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n\r\n      if (userData.username !== tab) {\r\n        let msgs = privateChats.get(tab) || [];\r\n        msgs.push(chatMessage);\r\n        setPrivateChats(new Map(privateChats.set(tab, msgs)));\r\n      }\r\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const searchUsers = async () => {\r\n    try {\r\n      const response = await axios.get(`http://localhost:8080/api/users/search`, {\r\n        params: { query: searchQuery }\r\n      });\r\n      setAllUsers(response.data);\r\n    } catch (error) {\r\n      console.error('Error searching users:', error);\r\n    }\r\n  };\r\n\r\n  const loadChatHistory = async () => {\r\n    if (!userData.connected) {\r\n      return;\r\n    }\r\n    try {\r\n      const response = await axios.get('http://localhost:8080/api/chats/history');\r\n      const sortedMessages = response.data\r\n        .filter(msg => msg.message !== null && msg.message.trim() !== '')\r\n        .sort((a, b) => new Date(a.date) - new Date(b.date));\r\n      setPublicChats(sortedMessages);\r\n    } catch (error) {\r\n      console.error('Error loading chat history:', error);\r\n    }\r\n  };\r\n\r\n  const onMessageReceived = (payload) => {\r\n    const payloadData = JSON.parse(payload.body);\r\n    switch (payloadData.status) {\r\n      case \"USER_DISCONNECTED\":\r\n        setAllUsers((prevUsers) => prevUsers.map((user) => {\r\n          if (user.username === payloadData.username) {\r\n            return { ...user, isConnected: false };\r\n          }\r\n          return user;\r\n        }));\r\n        break;\r\n      case \"JOIN\":\r\n        if (!privateChats.get(payloadData.senderName)) {\r\n          privateChats.set(payloadData.senderName, []);\r\n          setPrivateChats(new Map(privateChats));\r\n        }\r\n        fetchAllUsers();\r\n        break;\r\n      case \"MESSAGE\":\r\n        if (payloadData.message.trim() !== '') {\r\n          if (payloadData.receiverName === \"CHATROOM\" && payloadData.senderName !== userData.username) {\r\n            if (!publicChats.find(msg => msg.id === payloadData.id)) {\r\n              setPublicChats(prevPublicChats => [...prevPublicChats, payloadData]);\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      case \"NEW_USER\":\r\n        fetchAllUsers();\r\n        break;\r\n      default:\r\n        setAllUsers(prevAllUsers => [...prevAllUsers, payloadData]);\r\n        break;\r\n    }\r\n  };\r\n\r\n  const sanitizeInput = (input) => {\r\n    return DOMPurify.sanitize(input);\r\n  };\r\n\r\n  const onPrivateMessage = (payload) => {\r\n    const payloadData = JSON.parse(payload.body);\r\n\r\n    if (payloadData.senderName === userData.username && tab === userData.username) {\r\n      return;\r\n    }\r\n\r\n    if (payloadData.message.trim() === '') {\r\n      return;\r\n    }\r\n\r\n    setPrivateChats(prevChats => {\r\n      const updatedChats = new Map(prevChats);\r\n      const currentMessages = updatedChats.get(payloadData.senderName) || [];\r\n      const isDuplicate = currentMessages.some(msg => msg.id === payloadData.id);\r\n      if (!isDuplicate) {\r\n        updatedChats.set(payloadData.senderName, [...currentMessages, payloadData]);\r\n      }\r\n      return updatedChats;\r\n    });\r\n\r\n    if (tab !== payloadData.senderName) {\r\n      setUnreadMessages(prevUnreadMessages => {\r\n        const newUnreadMessages = new Map(prevUnreadMessages);\r\n        const count = newUnreadMessages.get(payloadData.senderName) || 0;\r\n        newUnreadMessages.set(payloadData.senderName, count + 1);\r\n        return newUnreadMessages;\r\n      });\r\n    }\r\n  };\r\n\r\n  const updateUserOnlineStatus = (username, online) => {\r\n    setAllUsers(prevUsers => prevUsers.map(user =>\r\n      user.username === username ? { ...user, online } : user\r\n    ));\r\n  };\r\n\r\n  const onError = (err) => {\r\n    console.log(err);\r\n  }\r\n\r\n  const handleLogin = async (event) => {\r\n    event.preventDefault();\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/users/login', {\r\n        username: userData.username,\r\n        password: userData.password,\r\n      });\r\n      if (response.data.success) {\r\n        setUserData({ ...userData, connected: true });\r\n      } else {\r\n        setUserData({ ...userData, errors: response.data.errors });\r\n      }\r\n    } catch (error) {\r\n      console.error('Error during login:', error);\r\n    }\r\n  };\r\n\r\n  const handleRegister = async (event) => {\r\n    event.preventDefault();\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/users/register', {\r\n        username: userData.username,\r\n        password: userData.password,\r\n        email: userData.email,\r\n      });\r\n      if (response.data.success) {\r\n        setIsRegistering(false);\r\n      } else {\r\n        setUserData({ ...userData, errors: response.data.errors });\r\n      }\r\n    } catch (error) {\r\n      console.error('Error during registration:', error);\r\n    }\r\n  };\r\n\r\n  const registerUser = () => {\r\n    setIsRegistering(true);\r\n  };\r\n\r\n  const loginUser = () => {\r\n    setIsRegistering(false);\r\n  };\r\n\r\n  return (\r\n    <div className=\"container\">\r\n      {!userData.connected ? (\r\n        <div className=\"login-register-form\">\r\n          {isRegistering ? (\r\n            <form onSubmit={handleRegister}>\r\n              <h2>Register</h2>\r\n              <input\r\n                type=\"text\"\r\n                name=\"username\"\r\n                placeholder=\"Enter your username\"\r\n                value={sanitizeInput(userData.username)}\r\n                onChange={(e) => setUserData({ ...userData, username: e.target.value })}\r\n                required\r\n              />\r\n              <input\r\n                type=\"email\"\r\n                name=\"email\"\r\n                placeholder=\"Enter your email\"\r\n                value={sanitizeInput(userData.email)}\r\n                onChange={(e) => setUserData({ ...userData, email: e.target.value })}\r\n                required\r\n              />\r\n              <input\r\n                type=\"password\"\r\n                name=\"password\"\r\n                placeholder=\"Enter your password\"\r\n                value={sanitizeInput(userData.password)}\r\n                onChange={(e) => setUserData({ ...userData, password: e.target.value })}\r\n                required\r\n              />\r\n              <button type=\"submit\">Register</button>\r\n              <button type=\"button\" onClick={loginUser}>Back to Login</button>\r\n            </form>\r\n          ) : (\r\n            <form onSubmit={handleLogin}>\r\n              <h2>Login</h2>\r\n              <input\r\n                type=\"text\"\r\n                name=\"username\"\r\n                placeholder=\"Enter your username\"\r\n                value={sanitizeInput(userData.username)}\r\n                onChange={(e) => setUserData({ ...userData, username: e.target.value })}\r\n                required\r\n              />\r\n              <input\r\n                type=\"password\"\r\n                name=\"password\"\r\n                placeholder=\"Enter your password\"\r\n                value={sanitizeInput(userData.password)}\r\n                onChange={(e) => setUserData({ ...userData, password: e.target.value })}\r\n                required\r\n              />\r\n              <button type=\"submit\">Login</button>\r\n              <button type=\"button\" onClick={registerUser}>Register</button>\r\n            </form>\r\n          )}\r\n        </div>\r\n      ) : (\r\n        <ChatRoomUI\r\n          userData={userData}\r\n          publicChats={publicChats}\r\n          privateChats={privateChats}\r\n          tab={tab}\r\n          unreadMessages={unreadMessages}\r\n          allUsers={allUsers}\r\n          searchQuery={searchQuery}\r\n          setTab={setTab}\r\n          setUserData={setUserData}\r\n          sendPrivateValue={sendPrivateValue}\r\n          setSearchQuery={setSearchQuery}\r\n          searchUsers={searchUsers}\r\n        />\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default ChatRoom;\r\n"]},"metadata":{},"sourceType":"module"}