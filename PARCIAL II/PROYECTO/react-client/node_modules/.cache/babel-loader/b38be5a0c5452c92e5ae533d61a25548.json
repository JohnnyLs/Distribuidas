{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\USER\\\\Documents\\\\GitHub\\\\Distribuidas\\\\Distribuidas\\\\PARCIAL II\\\\PROYECTO\\\\react-client\\\\src\\\\components\\\\ChatRoom.js\",\n    _s = $RefreshSig$();\n\n// import React, { useEffect, useState } from 'react';\n// import { over } from 'stompjs';\n// import SockJS from 'sockjs-client';\n// import ChatRoomUI from './ChatRoomUI';\n// var stompClient = null;\n// const ChatRoom = () => {\n//   const [privateChats, setPrivateChats] = useState(new Map());\n//   const [publicChats, setPublicChats] = useState([]);\n//   const [tab, setTab] = useState(\"CHATROOM\");\n//   const [unreadMessages, setUnreadMessages] = useState(new Map());\n//   const [userData, setUserData] = useState({\n//     username: '',\n//     receivername: '',\n//     connected: false,\n//     message: ''\n//   });\n//   useEffect(() => {\n//     console.log(userData);\n//   }, [userData]);\n//   const connect = () => {\n//     let Sock = new SockJS('http://localhost:8080/ws');\n//     stompClient = over(Sock);\n//     stompClient.connect({}, onConnected, onError);\n//   }\n// /*\n//   const onConnected = () => {\n//     setUserData({ ...userData, \"connected\": true });\n//     stompClient.subscribe('/chatroom/public', onMessageReceived);\n//     stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\n//     userJoin();\n//   }*/\n//     const onConnected = () => {\n//       setUserData({ ...userData, \"connected\": true });\n//       stompClient.subscribe('/chatroom/public', onMessageReceived);\n//       stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\n//       stompClient.subscribe('/user/' + userData.username + '/queue/notifications', onNotificationReceived); // Nueva suscripción\n//       userJoin();\n//   }\n//   const onNotificationReceived = (payload) => {\n//       var notification = JSON.parse(payload.body);\n//       alert(notification.message); // Muestra una alerta, puedes personalizar esto para mostrar notificaciones en tu UI\n//   }\n//   const userJoin = () => {\n//     var chatMessage = {\n//       senderName: userData.username,\n//       status: \"JOIN\"\n//     };\n//     stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\n//   }\n//   const onMessageReceived = (payload) => {\n//     var payloadData = JSON.parse(payload.body);\n//     switch (payloadData.status) {\n//       case \"JOIN\":\n//         if (!privateChats.get(payloadData.senderName)) {\n//           privateChats.set(payloadData.senderName, []);\n//           setPrivateChats(new Map(privateChats));\n//         }\n//         break;\n//       case \"MESSAGE\":\n//         publicChats.push(payloadData);\n//         setPublicChats([...publicChats]);\n//         break;\n//     }\n//   }\n// /*\n//   const onPrivateMessage = (payload) => {\n//     console.log(payload);\n//     var payloadData = JSON.parse(payload.body);\n//     if (privateChats.get(payloadData.senderName)) {\n//       privateChats.get(payloadData.senderName).push(payloadData);\n//       setPrivateChats(new Map(privateChats));\n//     } else {\n//       let list = [];\n//       list.push(payloadData);\n//       privateChats.set(payloadData.senderName, list);\n//       setPrivateChats(new Map(privateChats));\n//     }\n//   }*/\n//     const onPrivateMessage = (payload) => {\n//       var payloadData = JSON.parse(payload.body);\n//       if (privateChats.get(payloadData.senderName)) {\n//         privateChats.get(payloadData.senderName).push(payloadData);\n//         setPrivateChats(new Map(privateChats));\n//       } else {\n//         let list = [];\n//         list.push(payloadData);\n//         privateChats.set(payloadData.senderName, list);\n//         setPrivateChats(new Map(privateChats));\n//       }\n//       if (tab !== payloadData.senderName) {\n//         let count = unreadMessages.get(payloadData.senderName) || 0;\n//         unreadMessages.set(payloadData.senderName, count + 1);\n//         setUnreadMessages(new Map(unreadMessages));\n//       }\n//     }\n//     const handleTabChange = (name) => {\n//       setTab(name);\n//       if (unreadMessages.get(name)) {\n//         unreadMessages.set(name, 0);\n//         setUnreadMessages(new Map(unreadMessages));\n//       }\n//     };\n//   const onError = (err) => {\n//     console.log(err);\n//   }\n//   const handleMessage = (event) => {\n//     const { value } = event.target;\n//     setUserData({ ...userData, \"message\": value });\n//   }\n//   const sendValue = () => {\n//     if (stompClient) {\n//       var chatMessage = {\n//         senderName: userData.username,\n//         message: userData.message,\n//         status: \"MESSAGE\"\n//       };\n//       console.log(chatMessage);\n//       stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\n//       setUserData({ ...userData, \"message\": \"\" });\n//     }\n//   }\n//   const sendPrivateValue = () => {\n//     if (stompClient) {\n//       var chatMessage = {\n//         senderName: userData.username,\n//         receiverName: tab,\n//         message: userData.message,\n//         status: \"MESSAGE\"\n//       };\n//       if (userData.username !== tab) {\n//         privateChats.get(tab).push(chatMessage);\n//         setPrivateChats(new Map(privateChats));\n//       }\n//       stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\n//       setUserData({ ...userData, \"message\": \"\" });\n//     }\n//   }\n//   const handleUsername = (event) => {\n//     const { value } = event.target;\n//     setUserData({ ...userData, \"username\": value });\n//   }\n//   const registerUser = () => {\n//     connect();\n//   }\n// /*\n//   return (\n//     <ChatRoomUI\n//       userData={userData}\n//       privateChats={privateChats}\n//       publicChats={publicChats}\n//       tab={tab}\n//       setTab={setTab}\n//       handleMessage={handleMessage}\n//       sendValue={sendValue}\n//       sendPrivateValue={sendPrivateValue}\n//       handleUsername={handleUsername}\n//       registerUser={registerUser}\n//     />\n//   );*/\n//   return (\n//     <ChatRoomUI\n//       userData={userData}\n//       privateChats={privateChats}\n//       publicChats={publicChats}\n//       tab={tab}\n//       //setTab={setTab}\n//       setTab={handleTabChange}\n//       handleMessage={handleMessage}\n//       sendValue={sendValue}\n//       sendPrivateValue={sendPrivateValue}\n//       handleUsername={handleUsername}\n//       registerUser={registerUser}\n//       unreadMessages={unreadMessages}\n//       //setUnreadMessages={setUnreadMessages} // Añadir esta línea\n//     />\n//   );\n// }\n// export default ChatRoom;\n\n/* \r\nimport React, { useEffect, useState } from 'react';\r\nimport { over } from 'stompjs';\r\nimport SockJS from 'sockjs-client';\r\nimport ChatRoomUI from './ChatRoomUI';\r\n\r\nlet stompClient = null;\r\n\r\nconst ChatRoom = () => {\r\n  const [privateChats, setPrivateChats] = useState(new Map());\r\n  const [publicChats, setPublicChats] = useState([]);\r\n  const [tab, setTab] = useState(\"CHATROOM\");\r\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\r\n\r\n  const [userData, setUserData] = useState({\r\n    username: '',\r\n    receivername: '',\r\n    connected: false,\r\n    message: ''\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (userData.connected) {\r\n      connect();\r\n    }\r\n  }, [userData.connected]);\r\n\r\n  const connect = () => {\r\n    let Sock = new SockJS('http://localhost:8080/ws');\r\n    stompClient = over(Sock);\r\n    stompClient.connect({}, onConnected, onError);\r\n  }\r\n\r\n  const onConnected = () => {\r\n    setUserData({ ...userData, connected: true });\r\n    stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n    stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n    stompClient.subscribe('/user/' + userData.username + '/queue/notifications', onNotificationReceived);\r\n    userJoin();\r\n  }\r\n\r\n  const onNotificationReceived = (payload) => {\r\n    var notification = JSON.parse(payload.body);\r\n    alert(notification.message); // Muestra una alerta, puedes personalizar esto para mostrar notificaciones en tu UI\r\n  }\r\n\r\n  const userJoin = () => {\r\n    var chatMessage = {\r\n      senderName: userData.username,\r\n      status: \"JOIN\"\r\n    };\r\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n  }\r\n\r\n  const onMessageReceived = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    switch (payloadData.status) {\r\n      case \"JOIN\":\r\n        if (!privateChats.get(payloadData.senderName)) {\r\n          privateChats.set(payloadData.senderName, []);\r\n          setPrivateChats(new Map(privateChats));\r\n        }\r\n        break;\r\n      case \"MESSAGE\":\r\n        publicChats.push(payloadData);\r\n        setPublicChats([...publicChats]);\r\n        break;\r\n    }\r\n  }\r\n\r\n  const onPrivateMessage = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    if (privateChats.get(payloadData.senderName)) {\r\n      privateChats.get(payloadData.senderName).push(payloadData);\r\n      setPrivateChats(new Map(privateChats));\r\n    } else {\r\n      let list = [];\r\n      list.push(payloadData);\r\n      privateChats.set(payloadData.senderName, list);\r\n      setPrivateChats(new Map(privateChats));\r\n    }\r\n\r\n    if (tab !== payloadData.senderName) {\r\n      let count = unreadMessages.get(payloadData.senderName) || 0;\r\n      unreadMessages.set(payloadData.senderName, count + 1);\r\n      setUnreadMessages(new Map(unreadMessages));\r\n    }\r\n  }\r\n\r\n  const handleTabChange = (name) => {\r\n    setTab(name);\r\n    if (unreadMessages.get(name)) {\r\n      unreadMessages.set(name, 0);\r\n      setUnreadMessages(new Map(unreadMessages));\r\n    }\r\n  };\r\n\r\n  const onError = (err) => {\r\n    console.log(err);\r\n  }\r\n\r\n  const handleMessage = (event) => {\r\n    const { value } = event.target;\r\n    setUserData({ ...userData, message: value });\r\n  }\r\n\r\n  const sendValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n      stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const sendPrivateValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        receiverName: tab,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n\r\n      if (userData.username !== tab) {\r\n        privateChats.get(tab).push(chatMessage);\r\n        setPrivateChats(new Map(privateChats));\r\n      }\r\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const handleUsername = (event) => {\r\n    const { value } = event.target;\r\n    setUserData({ ...userData, username: value });\r\n  }\r\n\r\n  const registerUser = () => {\r\n    setUserData({ ...userData, connected: true });\r\n  }\r\n\r\n  return (\r\n    <ChatRoomUI\r\n      userData={userData}\r\n      privateChats={privateChats}\r\n      publicChats={publicChats}\r\n      tab={tab}\r\n      setTab={handleTabChange}\r\n      handleMessage={handleMessage}\r\n      sendValue={sendValue}\r\n      sendPrivateValue={sendPrivateValue}\r\n      handleUsername={handleUsername}\r\n      registerUser={registerUser}\r\n      unreadMessages={unreadMessages}\r\n    />\r\n  );\r\n}\r\n\r\nexport default ChatRoom;\r\n\r\n */\n\n/*\r\nimport React, { useEffect, useState } from 'react';\r\nimport { over } from 'stompjs';\r\nimport SockJS from 'sockjs-client';\r\nimport ChatRoomUI from './ChatRoomUI';\r\nimport axios from 'axios';\r\n\r\n\r\nlet stompClient = null;\r\n\r\nconst ChatRoom = () => {\r\n  const [privateChats, setPrivateChats] = useState(new Map());\r\n  const [publicChats, setPublicChats] = useState([]);\r\n  const [tab, setTab] = useState(\"CHATROOM\");\r\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\r\n\r\n  const [userData, setUserData] = useState({\r\n    username: '',\r\n    password: '',\r\n    email: '',\r\n    receivername: '',\r\n    connected: false,\r\n    message: ''\r\n  });\r\n\r\n  const [isRegistering, setIsRegistering] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (userData.connected) {\r\n      connect();\r\n    }\r\n  }, [userData.connected]);\r\n\r\n    const connect = () => {\r\n      let Sock = new SockJS('http://localhost:8080/ws');\r\n      stompClient = over(Sock);\r\n      stompClient.connect({username: userData.username}, onConnected, onError);\r\n    }\r\n\r\n  const onConnected = () => {\r\n    setUserData({ ...userData, connected: true });\r\n    stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n    stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n    userJoin();\r\n  }\r\n\r\n  const onNotificationReceived = (payload) => {\r\n    var notification = JSON.parse(payload.body);\r\n    alert(notification.message); // Muestra una alerta, puedes personalizar esto para mostrar notificaciones en tu UI\r\n  }\r\n\r\n  const userJoin = () => {\r\n    var chatMessage = {\r\n      senderName: userData.username,\r\n      status: \"JOIN\"\r\n    };\r\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n  }\r\n\r\n  const onMessageReceived = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    switch (payloadData.status) {\r\n      case \"JOIN\":\r\n        if (!privateChats.get(payloadData.senderName)) {\r\n          privateChats.set(payloadData.senderName, []);\r\n          setPrivateChats(new Map(privateChats));\r\n        }\r\n        break;\r\n      case \"MESSAGE\":\r\n        publicChats.push(payloadData);\r\n        setPublicChats([...publicChats]);\r\n        break;\r\n    }\r\n  }\r\n\r\n  const onPrivateMessage = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    if (privateChats.get(payloadData.senderName)) {\r\n      privateChats.get(payloadData.senderName).push(payloadData);\r\n      setPrivateChats(new Map(privateChats));\r\n    } else {\r\n      let list = [];\r\n      list.push(payloadData);\r\n      privateChats.set(payloadData.senderName, list);\r\n      setPrivateChats(new Map(privateChats));\r\n    }\r\n\r\n    if (tab !== payloadData.senderName) {\r\n      let count = unreadMessages.get(payloadData.senderName) || 0;\r\n      unreadMessages.set(payloadData.senderName, count + 1);\r\n      setUnreadMessages(new Map(unreadMessages));\r\n    }\r\n  }\r\n\r\n  const handleTabChange = (name) => {\r\n    setTab(name);\r\n    if (unreadMessages.get(name)) {\r\n      unreadMessages.set(name, 0);\r\n      setUnreadMessages(new Map(unreadMessages));\r\n    }\r\n  };\r\n\r\n  const onError = (err) => {\r\n    console.log(err);\r\n  }\r\n\r\n  const handleMessage = (event) => {\r\n    const { value } = event.target;\r\n    setUserData({ ...userData, message: value });\r\n  }\r\n\r\n  const sendValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n      stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const sendPrivateValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        receiverName: tab,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n\r\n      if (userData.username !== tab) {\r\n        privateChats.get(tab).push(chatMessage);\r\n        setPrivateChats(new Map(privateChats));\r\n      }\r\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const handleUsername = (event) => {\r\n    const { name, value } = event.target;\r\n    setUserData({ ...userData, [name]: value });\r\n  }\r\n\r\n  const registerUser = async () => {\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/register', {\r\n        username: userData.username,\r\n        password: userData.password,\r\n        email: userData.email\r\n      });\r\n      console.log(response.data);\r\n      setIsRegistering(false);\r\n    } catch (error) {\r\n      console.error('Registration failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  const loginUser = async () => {\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/login', {\r\n        username: userData.username,\r\n        password: userData.password\r\n      });\r\n      console.log(response.data);\r\n      setUserData({ ...userData, connected: true });\r\n    } catch (error) {\r\n      console.error('Login failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  return (\r\n    <ChatRoomUI\r\n      userData={userData}\r\n      privateChats={privateChats}\r\n      publicChats={publicChats}\r\n      tab={tab}\r\n      setTab={setTab}\r\n      handleMessage={handleMessage}\r\n      sendValue={sendValue}\r\n      sendPrivateValue={sendPrivateValue}\r\n      handleUsername={handleUsername}\r\n      registerUser={registerUser}\r\n      loginUser={loginUser}\r\n      unreadMessages={unreadMessages}\r\n      isRegistering={isRegistering}\r\n      setIsRegistering={setIsRegistering}\r\n    />\r\n  );\r\n}\r\n\r\nexport default ChatRoom;\r\n\r\n*/\n\n/*\r\nimport React, { useEffect, useState } from 'react';\r\nimport { over } from 'stompjs';\r\nimport SockJS from 'sockjs-client';\r\nimport ChatRoomUI from './ChatRoomUI';\r\nimport axios from 'axios';\r\n\r\nlet stompClient = null;\r\n\r\nconst ChatRoom = () => {\r\n  const [privateChats, setPrivateChats] = useState(new Map());\r\n  const [publicChats, setPublicChats] = useState([]);\r\n  const [tab, setTab] = useState(\"CHATROOM\");\r\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\r\n\r\n  const [userData, setUserData] = useState({\r\n    username: '',\r\n    password: '',\r\n    email: '',\r\n    receivername: '',\r\n    connected: false,\r\n    message: ''\r\n  });\r\n\r\n  const [isRegistering, setIsRegistering] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (userData.connected) {\r\n      connect();\r\n    }\r\n  }, [userData.connected]);\r\n\r\n  const connect = () => {\r\n    let Sock = new SockJS('http://localhost:8080/ws');\r\n    stompClient = over(Sock);\r\n    stompClient.connect({username: userData.username}, onConnected, onError);\r\n  }\r\n\r\n  const onConnected = () => {\r\n    setUserData({ ...userData, connected: true });\r\n    stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n    stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n    userJoin();\r\n  }\r\n\r\n  const userJoin = () => {\r\n    var chatMessage = {\r\n      senderName: userData.username,\r\n      status: \"JOIN\"\r\n    };\r\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n  }\r\n\r\n  const onMessageReceived = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    switch (payloadData.status) {\r\n      case \"JOIN\":\r\n        if (!privateChats.get(payloadData.senderName)) {\r\n          privateChats.set(payloadData.senderName, []);\r\n          setPrivateChats(new Map(privateChats));\r\n        }\r\n        break;\r\n      case \"MESSAGE\":\r\n        publicChats.push(payloadData);\r\n        setPublicChats([...publicChats]);\r\n        break;\r\n    }\r\n  }\r\n\r\n  const onPrivateMessage = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    if (privateChats.get(payloadData.senderName)) {\r\n      privateChats.get(payloadData.senderName).push(payloadData);\r\n      setPrivateChats(new Map(privateChats));\r\n    } else {\r\n      let list = [];\r\n      list.push(payloadData);\r\n      privateChats.set(payloadData.senderName, list);\r\n      setPrivateChats(new Map(privateChats));\r\n    }\r\n\r\n    if (tab !== payloadData.senderName) {\r\n      let count = unreadMessages.get(payloadData.senderName) || 0;\r\n      unreadMessages.set(payloadData.senderName, count + 1);\r\n      setUnreadMessages(new Map(unreadMessages));\r\n    }\r\n  }\r\n\r\n  const handleTabChange = (name) => {\r\n    setTab(name);\r\n    if (unreadMessages.get(name)) {\r\n      unreadMessages.set(name, 0);\r\n      setUnreadMessages(new Map(unreadMessages));\r\n    }\r\n  };\r\n\r\n  const onError = (err) => {\r\n    console.log(err);\r\n  }\r\n\r\n  const handleMessage = (event) => {\r\n    const { value } = event.target;\r\n    setUserData({ ...userData, message: value });\r\n  }\r\n\r\n  const sendValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n      stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const sendPrivateValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        receiverName: tab,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n\r\n      if (userData.username !== tab) {\r\n        privateChats.get(tab).push(chatMessage);\r\n        setPrivateChats(new Map(privateChats));\r\n      }\r\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const handleUsername = (event) => {\r\n    const { name, value } = event.target;\r\n    setUserData({ ...userData, [name]: value });\r\n  }\r\n\r\n  const registerUser = async () => {\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/register', {\r\n        username: userData.username,\r\n        password: userData.password,\r\n        email: userData.email\r\n      });\r\n      console.log(response.data);\r\n      setIsRegistering(false);\r\n    } catch (error) {\r\n      console.error('Registration failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  const loginUser = async () => {\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/login', {\r\n        username: userData.username,\r\n        password: userData.password\r\n      });\r\n      console.log(response.data);\r\n      setUserData({ ...userData, connected: true });\r\n    } catch (error) {\r\n      console.error('Login failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  return (\r\n    <ChatRoomUI\r\n      userData={userData}\r\n      privateChats={privateChats}\r\n      publicChats={publicChats}\r\n      tab={tab}\r\n      setTab={handleTabChange}\r\n      handleMessage={handleMessage}\r\n      sendValue={sendValue}\r\n      sendPrivateValue={sendPrivateValue}\r\n      handleUsername={handleUsername}\r\n      registerUser={registerUser}\r\n      loginUser={loginUser}\r\n      unreadMessages={unreadMessages}\r\n      isRegistering={isRegistering}\r\n      setIsRegistering={setIsRegistering}\r\n    />\r\n  );\r\n}\r\n\r\nexport default ChatRoom;*/\n\n/*\r\nimport React, { useEffect, useState } from 'react';\r\nimport { over } from 'stompjs';\r\nimport SockJS from 'sockjs-client';\r\nimport ChatRoomUI from './ChatRoomUI';\r\nimport axios from 'axios';\r\n\r\nlet stompClient = null;\r\n\r\nconst ChatRoom = () => {\r\n  const [privateChats, setPrivateChats] = useState(new Map());\r\n  const [publicChats, setPublicChats] = useState([]);\r\n  const [tab, setTab] = useState(\"CHATROOM\");\r\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\r\n\r\n  const [userData, setUserData] = useState({\r\n    username: '',\r\n    password: '',\r\n    email: '',\r\n    receivername: '',\r\n    connected: false,\r\n    message: ''\r\n  });\r\n\r\n  const [isRegistering, setIsRegistering] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (userData.connected) {\r\n      connect();\r\n    }\r\n  }, [userData.connected]);\r\n\r\n  const connect = () => {\r\n    let Sock = new SockJS('http://localhost:8080/ws');\r\n    stompClient = over(Sock);\r\n    stompClient.connect({username: userData.username}, onConnected, onError);\r\n  }\r\n\r\n  const onConnected = () => {\r\n    setUserData({ ...userData, connected: true });\r\n    stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n    stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n    userJoin();\r\n  }\r\n\r\n  const userJoin = () => {\r\n    var chatMessage = {\r\n      senderName: userData.username,\r\n      status: \"JOIN\"\r\n    };\r\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n  }\r\n\r\n  const onMessageReceived = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    switch (payloadData.status) {\r\n      case \"JOIN\":\r\n        if (!privateChats.get(payloadData.senderName)) {\r\n          privateChats.set(payloadData.senderName, []);\r\n          setPrivateChats(new Map(privateChats));\r\n        }\r\n        break;\r\n      case \"MESSAGE\":\r\n        publicChats.push(payloadData);\r\n        setPublicChats([...publicChats]);\r\n        break;\r\n    }\r\n  }\r\n\r\n  const onPrivateMessage = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    if (privateChats.get(payloadData.senderName)) {\r\n      privateChats.get(payloadData.senderName).push(payloadData);\r\n      setPrivateChats(new Map(privateChats));\r\n    } else {\r\n      let list = [];\r\n      list.push(payloadData);\r\n      privateChats.set(payloadData.senderName, list);\r\n      setPrivateChats(new Map(privateChats));\r\n    }\r\n\r\n    if (tab !== payloadData.senderName) {\r\n      setUnreadMessages(prevUnreadMessages => {\r\n        const newUnreadMessages = new Map(prevUnreadMessages);\r\n        const count = newUnreadMessages.get(payloadData.senderName) || 0;\r\n        newUnreadMessages.set(payloadData.senderName, count + 1);\r\n        return newUnreadMessages;\r\n      });\r\n    }\r\n  }\r\n\r\n  const handleTabChange = (name) => {\r\n    setTab(name);\r\n    setUnreadMessages(prevUnreadMessages => {\r\n      const newUnreadMessages = new Map(prevUnreadMessages);\r\n      newUnreadMessages.delete(name);\r\n      return newUnreadMessages;\r\n    });\r\n  };\r\n\r\n  const onError = (err) => {\r\n    console.log(err);\r\n  }\r\n\r\n  const handleMessage = (event) => {\r\n    const { value } = event.target;\r\n    setUserData({ ...userData, message: value });\r\n  }\r\n\r\n  const sendValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n      stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const sendPrivateValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        receiverName: tab,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n\r\n      if (userData.username !== tab) {\r\n        privateChats.get(tab).push(chatMessage);\r\n        setPrivateChats(new Map(privateChats));\r\n      }\r\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const handleUsername = (event) => {\r\n    const { name, value } = event.target;\r\n    setUserData({ ...userData, [name]: value });\r\n  }\r\n\r\n  const registerUser = async () => {\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/register', {\r\n        username: userData.username,\r\n        password: userData.password,\r\n        email: userData.email\r\n      });\r\n      console.log(response.data);\r\n      setIsRegistering(false);\r\n    } catch (error) {\r\n      console.error('Registration failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  const loginUser = async () => {\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/login', {\r\n        username: userData.username,\r\n        password: userData.password\r\n      });\r\n      console.log(response.data);\r\n      setUserData({ ...userData, connected: true });\r\n    } catch (error) {\r\n      console.error('Login failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  return (\r\n    <ChatRoomUI\r\n      userData={userData}\r\n      privateChats={privateChats}\r\n      publicChats={publicChats}\r\n      tab={tab}\r\n      setTab={handleTabChange}\r\n      handleMessage={handleMessage}\r\n      sendValue={sendValue}\r\n      sendPrivateValue={sendPrivateValue}\r\n      handleUsername={handleUsername}\r\n      registerUser={registerUser}\r\n      loginUser={loginUser}\r\n      unreadMessages={unreadMessages}\r\n      isRegistering={isRegistering}\r\n      setIsRegistering={setIsRegistering}\r\n    />\r\n  );\r\n}\r\n\r\nexport default ChatRoom;\r\n\r\n*/\n\n/* \r\nimport React, { useEffect, useState } from 'react';\r\nimport { over } from 'stompjs';\r\nimport SockJS from 'sockjs-client';\r\nimport ChatRoomUI from './ChatRoomUI';\r\nimport axios from 'axios';\r\nimport DOMPurify from 'dompurify';\r\n\r\nlet stompClient = null;\r\n\r\nconst ChatRoom = () => {\r\n  const [privateChats, setPrivateChats] = useState(new Map());\r\n  const [publicChats, setPublicChats] = useState([]);\r\n  const [tab, setTab] = useState(\"CHATROOM\");\r\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\r\n  const [allUsers, setAllUsers] = useState([]);\r\n  const [searchQuery, setSearchQuery] = useState('');\r\n\r\n  const [userData, setUserData] = useState({\r\n    username: '',\r\n    password: '',\r\n    email: '',\r\n    receivername: '',\r\n    connected: false,\r\n    message: '',\r\n    errors: {}\r\n  });\r\n  const [isRegistering, setIsRegistering] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (userData.connected) {\r\n      connect();\r\n    }\r\n  }, [userData.connected]);\r\n\r\n  const connect = () => {\r\n    let Sock = new SockJS('http://localhost:8080/ws');\r\n    stompClient = over(Sock);\r\n    stompClient.connect({username: userData.username}, onConnected, onError);\r\n  }\r\n\r\n  const onConnected = () => {\r\n    setUserData({ ...userData, connected: true });\r\n    stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n    stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n    userJoin();\r\n  }\r\n\r\n  const userJoin = () => {\r\n    var chatMessage = {\r\n      senderName: userData.username,\r\n      status: \"JOIN\"\r\n    };\r\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n  }\r\n\r\n  const onMessageReceived = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    switch (payloadData.status) {\r\n      case \"JOIN\":\r\n        if (!privateChats.get(payloadData.senderName)) {\r\n          privateChats.set(payloadData.senderName, []);\r\n          setPrivateChats(new Map(privateChats));\r\n        }\r\n        break;\r\n      case \"MESSAGE\":\r\n        publicChats.push(payloadData);\r\n        setPublicChats([...publicChats]);\r\n        break;\r\n    }\r\n  }\r\n\r\n  const sanitizeInput = (input) => {\r\n    return DOMPurify.sanitize(input);\r\n  };\r\n\r\n  const onPrivateMessage = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    if (privateChats.get(payloadData.senderName)) {\r\n      privateChats.get(payloadData.senderName).push(payloadData);\r\n      setPrivateChats(new Map(privateChats));\r\n    } else {\r\n      let list = [];\r\n      list.push(payloadData);\r\n      privateChats.set(payloadData.senderName, list);\r\n      setPrivateChats(new Map(privateChats));\r\n    }\r\n\r\n    if (tab !== payloadData.senderName) {\r\n      setUnreadMessages(prevUnreadMessages => {\r\n        const newUnreadMessages = new Map(prevUnreadMessages);\r\n        const count = newUnreadMessages.get(payloadData.senderName) || 0;\r\n        newUnreadMessages.set(payloadData.senderName, count + 1);\r\n        return newUnreadMessages;\r\n      });\r\n    }\r\n  }\r\n\r\n  const handleTabChange = (name) => {\r\n    setTab(name);\r\n    setUnreadMessages(prevUnreadMessages => {\r\n      const newUnreadMessages = new Map(prevUnreadMessages);\r\n      newUnreadMessages.delete(name);\r\n      return newUnreadMessages;\r\n    });\r\n  };\r\n\r\n  const onError = (err) => {\r\n    console.log(err);\r\n  }\r\n\r\n  const handleMessage = (event) => {\r\n    const { value } = event.target;\r\n    setUserData({ ...userData, message: value });\r\n  }\r\n\r\n  const sendValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n      stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const sendPrivateValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        receiverName: tab,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n\r\n      if (userData.username !== tab) {\r\n        privateChats.get(tab).push(chatMessage);\r\n        setPrivateChats(new Map(privateChats));\r\n      }\r\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  \r\n  const handleUsername = (event) => {\r\n    const { name, value } = event.target;\r\n    \r\n    if (name === \"username\") {\r\n      const filteredValue = value.replace(/[^a-zA-Z0-9\\s]/g, '');\r\n      setUserData({ ...userData, [name]: filteredValue });\r\n    } else {\r\n      setUserData({ ...userData, [name]: value });\r\n      const sanitizedValue = DOMPurify.sanitize(value);\r\n      setUserData({ ...userData, [name]: sanitizedValue });\r\n    }\r\n  };\r\n\r\n\r\n \r\n\r\n  const validateEmail = (email) => {\r\n    const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n    return re.test(String(email).toLowerCase());\r\n  };\r\n\r\n  const validateUsername = (username) => {\r\n    const re = /^[a-zA-Z]+$/;\r\n    return re.test(username);\r\n  };\r\n\r\n  const validateFields = () => {\r\n    const errors = {};\r\n    if (!userData.username || !validateUsername(userData.username)) {\r\n      errors.username = \"El nombre de usuario solo puede contener letras\";\r\n    }\r\n    if (!userData.password) {\r\n      errors.password = \"La contraseña no puede estar vacía\";\r\n    }\r\n    if (!userData.email || !validateEmail(userData.email)) {\r\n      errors.email = \"El email no es válido\";\r\n    }\r\n    return errors;\r\n  };\r\n\r\n  const registerUser = async () => {\r\n    const errors = validateFields();\r\n    if (Object.keys(errors).length > 0) {\r\n      setUserData({ ...userData, errors });\r\n      return;\r\n    }\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/register', {\r\n        username: userData.username,\r\n        password: userData.password,\r\n        email: userData.email\r\n      });\r\n      console.log(response.data);\r\n      setIsRegistering(false);\r\n    } catch (error) {\r\n      console.error('Registration failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  const validateLoginFields = () => {\r\n    const errors = {};\r\n    if (!userData.username) {\r\n      errors.username = \"El nombre de usuario no puede estar vacío\";\r\n    }\r\n    if (!userData.password) {\r\n      errors.password = \"La contraseña no puede estar vacía\";\r\n    }\r\n    return errors;\r\n  };\r\n  \r\n  const loginUser = async () => {\r\n    const errors = validateLoginFields();\r\n    if (Object.keys(errors).length > 0) {\r\n      setUserData({ ...userData, errors });\r\n      return;\r\n    }\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/login', {\r\n        username: userData.username,\r\n        password: userData.password\r\n      });\r\n      console.log(response.data);\r\n      setUserData({ ...userData, connected: true, errors: {} });\r\n    } catch (error) {\r\n      console.error('Login failed:', error.response.data);\r\n      setUserData({ ...userData, errors: { ...errors, login: 'Nombre de usuario o contraseña incorrectos' } });\r\n    }\r\n  };\r\n\r\n  \r\n  return (\r\n    <ChatRoomUI\r\n      userData={userData}\r\n      privateChats={privateChats}\r\n      publicChats={publicChats}\r\n      tab={tab}\r\n      setTab={handleTabChange}\r\n      handleMessage={handleMessage}\r\n      sendValue={sendValue}\r\n      sendPrivateValue={sendPrivateValue}\r\n      handleUsername={handleUsername}\r\n      registerUser={registerUser}\r\n      loginUser={loginUser}\r\n      unreadMessages={unreadMessages}\r\n      isRegistering={isRegistering}\r\n      setIsRegistering={setIsRegistering}\r\n    />\r\n  );\r\n}\r\n\r\nexport default ChatRoom;\r\n\r\n\r\n\r\n\r\n\r\n */\nimport React, { useEffect, useState } from 'react';\nimport { over } from 'stompjs';\nimport SockJS from 'sockjs-client';\nimport ChatRoomUI from './ChatRoomUI';\nimport axios from 'axios';\nimport DOMPurify from 'dompurify';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet stompClient = null;\n\nconst ChatRoom = () => {\n  _s();\n\n  const [privateChats, setPrivateChats] = useState(new Map());\n  const [publicChats, setPublicChats] = useState([]);\n  const [tab, setTab] = useState(\"CHATROOM\");\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\n  const [allUsers, setAllUsers] = useState([]);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [userData, setUserData] = useState({\n    username: '',\n    password: '',\n    email: '',\n    receivername: '',\n    connected: false,\n    message: '',\n    errors: {}\n  });\n  const [isRegistering, setIsRegistering] = useState(false);\n  useEffect(() => {\n    if (userData.connected) {\n      connect();\n      fetchAllUsers();\n      loadChatHistory();\n    }\n  }, [userData.connected]);\n  useEffect(() => {\n    if (tab !== \"CHATROOM\" && userData.connected) {\n      loadPrivateChatHistory(tab);\n    }\n  }, [tab]);\n  /*\r\n  const loadPrivateChatHistory = async (receiverName) => {\r\n    try {\r\n      const response = await axios.get(`http://localhost:8080/api/chats/history?senderName=${userData.username}&receiverName=${receiverName}`);\r\n      setPrivateChats(new Map(privateChats.set(receiverName, response.data)));\r\n    } catch (error) {\r\n      console.error('Error loading private chat history:', error);\r\n    }\r\n  };*/\n\n  /*\r\n  const loadPrivateChatHistory = async (receiverName) => {\r\n    try {\r\n        const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=${receiverName}`);\r\n        const sortedMessages = response.data.sort((a, b) => new Date(a.date) - new Date(b.date));\r\n        setPrivateChats(new Map(privateChats.set(receiverName, sortedMessages)));\r\n    } catch (error) {\r\n        console.error('Error loading private chat history:', error);\r\n    }\r\n  };\r\n  \r\n  \r\n  const connect = () => {\r\n    let Sock = new SockJS('http://localhost:8080/ws');\r\n    stompClient = over(Sock);\r\n    stompClient.connect({username: userData.username}, onConnected, onError);\r\n  }\r\n    const onConnected = () => {\r\n    setUserData({ ...userData, connected: true });\r\n    stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n    stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n    userJoin();\r\n    fetchAllUsers();\r\n    loadChatHistory();\r\n  }\r\n    const userJoin = () => {\r\n    var chatMessage = {\r\n      senderName: userData.username,\r\n      status: \"JOIN\"\r\n    };\r\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n  }\r\n  const fetchAllUsers = async () => {\r\n    try {\r\n      const response = await axios.get('http://localhost:8080/api/users/all');\r\n      setAllUsers(response.data);\r\n    } catch (error) {\r\n      console.error('Failed to fetch users:', error);\r\n    }\r\n  };\r\n    const sendPrivateValue = () => {\r\n    if (stompClient) {\r\n        var chatMessage = {\r\n            senderName: userData.username,\r\n            receiverName: tab,\r\n            message: userData.message,\r\n            status: \"MESSAGE\"\r\n        };\r\n          if (userData.username !== tab) {\r\n            let msgs = privateChats.get(tab) || [];\r\n            msgs.push(chatMessage);\r\n            setPrivateChats(new Map(privateChats.set(tab, msgs)));\r\n        }\r\n        stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n        setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n  /*\r\n  const sendPrivateValue = () => {\r\n  if (stompClient) {\r\n      var chatMessage = {\r\n          senderName: userData.username,\r\n          receiverName: tab,\r\n          message: userData.message,\r\n          status: \"MESSAGE\"\r\n      };\r\n        if (userData.username !== tab) {\r\n          let msgs = privateChats.get(tab) || [];\r\n          msgs.push(chatMessage);\r\n          setPrivateChats(new Map(privateChats.set(tab, msgs)));\r\n      }\r\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n  }\r\n  }*/\n\n  const searchUsers = async () => {\n    try {\n      const response = await axios.get(`http://localhost:8080/api/users/search`, {\n        params: {\n          query: searchQuery\n        }\n      });\n      setAllUsers(response.data);\n    } catch (error) {\n      console.error('Error searching users:', error);\n    }\n  };\n  /*\r\n    const loadChatHistory = async () => {\r\n      try {\r\n          const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=ALL`);\r\n          setPublicChats(response.data);\r\n          \r\n      } catch (error) {\r\n          console.error('Error loading chat history:', error);\r\n      }\r\n  };*/\n\n  /*\r\n  const loadChatHistory = async () => {\r\n    try {\r\n        // Obtener mensajes públicos\r\n        const publicResponse = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=ALL`);\r\n        setPublicChats(publicResponse.data);\r\n  \r\n        // Obtener mensajes privados\r\n        const privateResponse = await axios.get(`http://localhost:8080/api/chats/history?senderName=${userData.username}&receiverName=${userData.username}`);\r\n        privateResponse.data.forEach(chat => {\r\n            let messages = privateChats.get(chat.receiverName) || [];\r\n            messages.push(chat);\r\n            setPrivateChats(new Map(privateChats.set(chat.receiverName, messages)));\r\n        });\r\n  \r\n    } catch (error) {\r\n        console.error('Error loading chat history:', error);\r\n    }\r\n  };*/\n\n\n  const loadChatHistory = async () => {\n    try {\n      const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=ALL`);\n      const sortedMessages = response.data.sort((a, b) => new Date(a.date) - new Date(b.date));\n      setPublicChats(sortedMessages);\n    } catch (error) {\n      console.error('Error loading chat history:', error);\n    }\n  }; // In the useEffect hook\n\n\n  useEffect(() => {\n    if (userData.connected) {\n      connect();\n      fetchAllUsers();\n      loadChatHistory();\n    }\n  }, [userData.connected]);\n  useEffect(() => {\n    if (tab !== \"CHATROOM\" && userData.connected) {\n      loadPrivateChatHistory(tab);\n    }\n  }, [tab]);\n  /*\r\n    const onMessageReceived = (payload) => {\r\n      var payloadData = JSON.parse(payload.body);\r\n      switch (payloadData.status) {\r\n        case \"JOIN\":\r\n          if (!privateChats.get(payloadData.senderName)) {\r\n            privateChats.set(payloadData.senderName, []);\r\n            setPrivateChats(new Map(privateChats));\r\n          }\r\n          break;\r\n        case \"MESSAGE\":\r\n          publicChats.push(payloadData);\r\n          setPublicChats([...publicChats]);\r\n          break;\r\n      }\r\n    }\r\n    */\n\n  const onMessageReceived = payload => {\n    var payloadData = JSON.parse(payload.body);\n\n    switch (payloadData.status) {\n      case \"JOIN\":\n        if (!privateChats.get(payloadData.senderName)) {\n          privateChats.set(payloadData.senderName, []);\n          setPrivateChats(new Map(privateChats));\n        }\n\n        fetchAllUsers();\n        break;\n\n      case \"MESSAGE\":\n        publicChats.push(payloadData);\n        setPublicChats([...publicChats]);\n        break;\n\n      case \"NEW_USER\":\n        fetchAllUsers(); // Actualizar la lista de usuarios cuando un nuevo usuario se registra\n\n        break;\n\n      default:\n        setAllUsers([...allUsers, payloadData]);\n        break;\n    }\n  };\n\n  const sanitizeInput = input => {\n    return DOMPurify.sanitize(input);\n  };\n  /*\r\n    const onPrivateMessage = (payload) => {\r\n      var payloadData = JSON.parse(payload.body);\r\n      if (privateChats.get(payloadData.senderName)) {\r\n        privateChats.get(payloadData.senderName).push(payloadData);\r\n        setPrivateChats(new Map(privateChats));\r\n      } else {\r\n        let list = [];\r\n        list.push(payloadData);\r\n        privateChats.set(payloadData.senderName, list);\r\n        setPrivateChats(new Map(privateChats));\r\n      }\r\n  \r\n      if (tab !== payloadData.senderName) {\r\n        setUnreadMessages(prevUnreadMessages => {\r\n          const newUnreadMessages = new Map(prevUnreadMessages);\r\n          const count = newUnreadMessages.get(payloadData.senderName) || 0;\r\n          newUnreadMessages.set(payloadData.senderName, count + 1);\r\n          return newUnreadMessages;\r\n        });\r\n      }\r\n    }*/\n\n  /*\r\n  const onPrivateMessage = (payload) => {\r\n    const payloadData = JSON.parse(payload.body);\r\n        // Agregar mensaje al chat privado del remitente\r\n    if (privateChats.get(payloadData.senderName)) {\r\n        privateChats.get(payloadData.senderName).push(payloadData);\r\n    } else {\r\n        let list = [];\r\n        list.push(payloadData);\r\n        privateChats.set(payloadData.senderName, list);\r\n    }\r\n    setPrivateChats(new Map(privateChats));\r\n        if (tab !== payloadData.senderName) {\r\n        setUnreadMessages(prevUnreadMessages => {\r\n            const newUnreadMessages = new Map(prevUnreadMessages);\r\n            const count = newUnreadMessages.get(payloadData.senderName) || 0;\r\n            newUnreadMessages.set(payloadData.senderName, count + 1);\r\n            return newUnreadMessages;\r\n        });\r\n    }\r\n  };*/\n\n\n  const onPrivateMessage = payload => {\n    const payloadData = JSON.parse(payload.body); // Agregar mensaje al chat privado del remitente\n\n    if (privateChats.get(payloadData.senderName)) {\n      privateChats.get(payloadData.senderName).push(payloadData);\n    } else {\n      let list = [];\n      list.push(payloadData);\n      privateChats.set(payloadData.senderName, list);\n    }\n\n    setPrivateChats(new Map(privateChats));\n\n    if (tab !== payloadData.senderName) {\n      setUnreadMessages(prevUnreadMessages => {\n        const newUnreadMessages = new Map(prevUnreadMessages);\n        const count = newUnreadMessages.get(payloadData.senderName) || 0;\n        newUnreadMessages.set(payloadData.senderName, count + 1);\n        return newUnreadMessages;\n      });\n    }\n  };\n\n  const updateUserOnlineStatus = (username, online) => {\n    setAllUsers(prevUsers => prevUsers.map(user => user.username === username ? { ...user,\n      online\n    } : user));\n  };\n\n  const renderUserStatus = user => {\n    return user.online ? /*#__PURE__*/_jsxDEV(\"span\", {\n      style: {\n        color: 'green'\n      },\n      children: \"Online\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1548,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(\"span\", {\n      style: {\n        color: 'red'\n      },\n      children: \"Offline\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1550,\n      columnNumber: 9\n    }, this);\n  };\n\n  const renderUserList = () => {\n    return allUsers.map(user => /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        margin: '10px 0'\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"span\", {\n        children: user.username\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1557,\n        columnNumber: 11\n      }, this), \" \", renderUserStatus(user)]\n    }, user.username, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1556,\n      columnNumber: 7\n    }, this));\n  };\n\n  const handleTabChange = name => {\n    setTab(name);\n    setUnreadMessages(prevUnreadMessages => {\n      const newUnreadMessages = new Map(prevUnreadMessages);\n      newUnreadMessages.delete(name);\n      return newUnreadMessages;\n    });\n  };\n\n  const handleSearch = event => {\n    const query = event.target.value;\n    setSearchQuery(query);\n\n    if (query.length > 0) {\n      searchUsers(query);\n    } else {\n      fetchAllUsers();\n    }\n  };\n\n  const onError = err => {\n    console.log(err);\n  };\n\n  const handleMessage = event => {\n    const {\n      value\n    } = event.target;\n    setUserData({ ...userData,\n      message: value\n    });\n  };\n\n  const sendValue = () => {\n    if (stompClient) {\n      var chatMessage = {\n        senderName: userData.username,\n        message: userData.message,\n        status: \"MESSAGE\"\n      };\n      stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\n      setUserData({ ...userData,\n        message: \"\"\n      });\n    }\n  };\n\n  const handleUsername = event => {\n    const {\n      name,\n      value\n    } = event.target;\n\n    if (name === \"username\") {\n      const filteredValue = value.replace(/[^a-zA-Z0-9\\s]/g, '');\n      setUserData({ ...userData,\n        [name]: filteredValue\n      });\n    } else {\n      setUserData({ ...userData,\n        [name]: value\n      });\n      const sanitizedValue = DOMPurify.sanitize(value);\n      setUserData({ ...userData,\n        [name]: sanitizedValue\n      });\n    }\n  };\n\n  const validateEmail = email => {\n    const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return re.test(String(email).toLowerCase());\n  };\n\n  const validateUsername = username => {\n    const re = /^[a-zA-Z]+$/;\n    return re.test(username);\n  };\n\n  const validateFields = () => {\n    const errors = {};\n\n    if (!userData.username || !validateUsername(userData.username)) {\n      errors.username = \"El nombre de usuario solo puede contener letras\";\n    }\n\n    if (!userData.password) {\n      errors.password = \"La contraseña no puede estar vacía\";\n    }\n\n    if (!userData.email || !validateEmail(userData.email)) {\n      errors.email = \"El email no es válido\";\n    }\n\n    return errors;\n  };\n\n  const registerUser = async () => {\n    const errors = validateFields();\n\n    if (Object.keys(errors).length > 0) {\n      setUserData({ ...userData,\n        errors\n      });\n      return;\n    }\n\n    try {\n      const response = await axios.post('http://localhost:8080/api/auth/register', {\n        username: userData.username,\n        password: userData.password,\n        email: userData.email\n      });\n      console.log(response.data);\n      setIsRegistering(false);\n    } catch (error) {\n      console.error('Registration failed:', error.response.data);\n    }\n  };\n\n  const validateLoginFields = () => {\n    const errors = {};\n\n    if (!userData.username) {\n      errors.username = \"El nombre de usuario no puede estar vacío\";\n    }\n\n    if (!userData.password) {\n      errors.password = \"La contraseña no puede estar vacía\";\n    }\n\n    return errors;\n  };\n\n  const loginUser = async () => {\n    const errors = validateLoginFields();\n\n    if (Object.keys(errors).length > 0) {\n      setUserData({ ...userData,\n        errors\n      });\n      return;\n    }\n\n    try {\n      const response = await axios.post('http://localhost:8080/api/auth/login', {\n        username: userData.username,\n        password: userData.password\n      });\n      console.log(response.data);\n      setUserData({ ...userData,\n        connected: true,\n        errors: {}\n      });\n    } catch (error) {\n      console.error('Login failed:', error.response.data);\n      setUserData({ ...userData,\n        errors: { ...errors,\n          login: 'Nombre de usuario o contraseña incorrectos'\n        }\n      });\n    }\n  };\n\n  return /*#__PURE__*/_jsxDEV(ChatRoomUI, {\n    userData: userData,\n    privateChats: privateChats,\n    publicChats: publicChats,\n    tab: tab,\n    setTab: handleTabChange,\n    handleMessage: handleMessage,\n    sendValue: sendValue,\n    sendPrivateValue: sendPrivateValue,\n    handleUsername: handleUsername,\n    registerUser: registerUser,\n    loginUser: loginUser,\n    unreadMessages: unreadMessages,\n    isRegistering: isRegistering,\n    setIsRegistering: setIsRegistering,\n    allUsers: allUsers,\n    searchQuery: searchQuery,\n    setSearchQuery: setSearchQuery,\n    searchUsers: searchUsers,\n    renderUserStatus: searchUsers,\n    renderUserList: searchUsers\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1698,\n    columnNumber: 5\n  }, this);\n};\n\n_s(ChatRoom, \"nH+SJfNDhyJxvgE4Ne87Q/obrGI=\");\n\n_c = ChatRoom;\nexport default ChatRoom;\n\nvar _c;\n\n$RefreshReg$(_c, \"ChatRoom\");","map":{"version":3,"sources":["C:/Users/USER/Documents/GitHub/Distribuidas/Distribuidas/PARCIAL II/PROYECTO/react-client/src/components/ChatRoom.js"],"names":["React","useEffect","useState","over","SockJS","ChatRoomUI","axios","DOMPurify","stompClient","ChatRoom","privateChats","setPrivateChats","Map","publicChats","setPublicChats","tab","setTab","unreadMessages","setUnreadMessages","allUsers","setAllUsers","searchQuery","setSearchQuery","userData","setUserData","username","password","email","receivername","connected","message","errors","isRegistering","setIsRegistering","connect","fetchAllUsers","loadChatHistory","loadPrivateChatHistory","searchUsers","response","get","params","query","data","error","console","sortedMessages","sort","a","b","Date","date","onMessageReceived","payload","payloadData","JSON","parse","body","status","senderName","set","push","sanitizeInput","input","sanitize","onPrivateMessage","list","prevUnreadMessages","newUnreadMessages","count","updateUserOnlineStatus","online","prevUsers","map","user","renderUserStatus","color","renderUserList","margin","handleTabChange","name","delete","handleSearch","event","target","value","length","onError","err","log","handleMessage","sendValue","chatMessage","send","stringify","handleUsername","filteredValue","replace","sanitizedValue","validateEmail","re","test","String","toLowerCase","validateUsername","validateFields","registerUser","Object","keys","post","validateLoginFields","loginUser","login","sendPrivateValue"],"mappings":";;;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA,OAAOA,KAAP,IAAgBC,SAAhB,EAA2BC,QAA3B,QAA2C,OAA3C;AACA,SAASC,IAAT,QAAqB,SAArB;AACA,OAAOC,MAAP,MAAmB,eAAnB;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,OAAOC,SAAP,MAAsB,WAAtB;;AAEA,IAAIC,WAAW,GAAG,IAAlB;;AAEA,MAAMC,QAAQ,GAAG,MAAM;AAAA;;AACrB,QAAM,CAACC,YAAD,EAAeC,eAAf,IAAkCT,QAAQ,CAAC,IAAIU,GAAJ,EAAD,CAAhD;AACA,QAAM,CAACC,WAAD,EAAcC,cAAd,IAAgCZ,QAAQ,CAAC,EAAD,CAA9C;AACA,QAAM,CAACa,GAAD,EAAMC,MAAN,IAAgBd,QAAQ,CAAC,UAAD,CAA9B;AACA,QAAM,CAACe,cAAD,EAAiBC,iBAAjB,IAAsChB,QAAQ,CAAC,IAAIU,GAAJ,EAAD,CAApD;AACA,QAAM,CAACO,QAAD,EAAWC,WAAX,IAA0BlB,QAAQ,CAAC,EAAD,CAAxC;AACA,QAAM,CAACmB,WAAD,EAAcC,cAAd,IAAgCpB,QAAQ,CAAC,EAAD,CAA9C;AAEA,QAAM,CAACqB,QAAD,EAAWC,WAAX,IAA0BtB,QAAQ,CAAC;AACvCuB,IAAAA,QAAQ,EAAE,EAD6B;AAEvCC,IAAAA,QAAQ,EAAE,EAF6B;AAGvCC,IAAAA,KAAK,EAAE,EAHgC;AAIvCC,IAAAA,YAAY,EAAE,EAJyB;AAKvCC,IAAAA,SAAS,EAAE,KAL4B;AAMvCC,IAAAA,OAAO,EAAE,EAN8B;AAOvCC,IAAAA,MAAM,EAAE;AAP+B,GAAD,CAAxC;AASA,QAAM,CAACC,aAAD,EAAgBC,gBAAhB,IAAoC/B,QAAQ,CAAC,KAAD,CAAlD;AAEAD,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIsB,QAAQ,CAACM,SAAb,EAAwB;AACtBK,MAAAA,OAAO;AACPC,MAAAA,aAAa;AACbC,MAAAA,eAAe;AAGhB;AACF,GARQ,EAQN,CAACb,QAAQ,CAACM,SAAV,CARM,CAAT;AAUA5B,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIc,GAAG,KAAK,UAAR,IAAsBQ,QAAQ,CAACM,SAAnC,EAA8C;AAC5CQ,MAAAA,sBAAsB,CAACtB,GAAD,CAAtB;AACD;AACF,GAJQ,EAIN,CAACA,GAAD,CAJM,CAAT;AAMA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AASA,QAAMuB,WAAW,GAAG,YAAY;AAC5B,QAAI;AACA,YAAMC,QAAQ,GAAG,MAAMjC,KAAK,CAACkC,GAAN,CAAW,wCAAX,EAAoD;AACvEC,QAAAA,MAAM,EAAE;AAAEC,UAAAA,KAAK,EAAErB;AAAT;AAD+D,OAApD,CAAvB;AAGAD,MAAAA,WAAW,CAACmB,QAAQ,CAACI,IAAV,CAAX;AACH,KALD,CAKE,OAAOC,KAAP,EAAc;AACZC,MAAAA,OAAO,CAACD,KAAR,CAAc,wBAAd,EAAwCA,KAAxC;AACH;AACJ,GATD;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,QAAMR,eAAe,GAAG,YAAY;AAClC,QAAI;AACA,YAAMG,QAAQ,GAAG,MAAMjC,KAAK,CAACkC,GAAN,CAAW,qDAAoDjB,QAAQ,CAACE,QAAS,mBAAjF,CAAvB;AACA,YAAMqB,cAAc,GAAGP,QAAQ,CAACI,IAAT,CAAcI,IAAd,CAAmB,CAACC,CAAD,EAAIC,CAAJ,KAAU,IAAIC,IAAJ,CAASF,CAAC,CAACG,IAAX,IAAmB,IAAID,IAAJ,CAASD,CAAC,CAACE,IAAX,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","sourcesContent":["// import React, { useEffect, useState } from 'react';\r\n// import { over } from 'stompjs';\r\n// import SockJS from 'sockjs-client';\r\n// import ChatRoomUI from './ChatRoomUI';\r\n\r\n// var stompClient = null;\r\n\r\n// const ChatRoom = () => {\r\n//   const [privateChats, setPrivateChats] = useState(new Map());\r\n//   const [publicChats, setPublicChats] = useState([]);\r\n//   const [tab, setTab] = useState(\"CHATROOM\");\r\n//   const [unreadMessages, setUnreadMessages] = useState(new Map());\r\n\r\n//   const [userData, setUserData] = useState({\r\n//     username: '',\r\n//     receivername: '',\r\n//     connected: false,\r\n//     message: ''\r\n//   });\r\n\r\n//   useEffect(() => {\r\n//     console.log(userData);\r\n//   }, [userData]);\r\n\r\n//   const connect = () => {\r\n//     let Sock = new SockJS('http://localhost:8080/ws');\r\n//     stompClient = over(Sock);\r\n//     stompClient.connect({}, onConnected, onError);\r\n//   }\r\n// /*\r\n//   const onConnected = () => {\r\n//     setUserData({ ...userData, \"connected\": true });\r\n//     stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n//     stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n//     userJoin();\r\n//   }*/\r\n\r\n//     const onConnected = () => {\r\n//       setUserData({ ...userData, \"connected\": true });\r\n//       stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n//       stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n//       stompClient.subscribe('/user/' + userData.username + '/queue/notifications', onNotificationReceived); // Nueva suscripción\r\n//       userJoin();\r\n//   }\r\n  \r\n//   const onNotificationReceived = (payload) => {\r\n//       var notification = JSON.parse(payload.body);\r\n//       alert(notification.message); // Muestra una alerta, puedes personalizar esto para mostrar notificaciones en tu UI\r\n//   }\r\n  \r\n\r\n//   const userJoin = () => {\r\n//     var chatMessage = {\r\n//       senderName: userData.username,\r\n//       status: \"JOIN\"\r\n//     };\r\n//     stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n//   }\r\n\r\n//   const onMessageReceived = (payload) => {\r\n//     var payloadData = JSON.parse(payload.body);\r\n//     switch (payloadData.status) {\r\n//       case \"JOIN\":\r\n//         if (!privateChats.get(payloadData.senderName)) {\r\n//           privateChats.set(payloadData.senderName, []);\r\n//           setPrivateChats(new Map(privateChats));\r\n//         }\r\n//         break;\r\n//       case \"MESSAGE\":\r\n//         publicChats.push(payloadData);\r\n//         setPublicChats([...publicChats]);\r\n//         break;\r\n//     }\r\n//   }\r\n// /*\r\n//   const onPrivateMessage = (payload) => {\r\n//     console.log(payload);\r\n//     var payloadData = JSON.parse(payload.body);\r\n//     if (privateChats.get(payloadData.senderName)) {\r\n//       privateChats.get(payloadData.senderName).push(payloadData);\r\n//       setPrivateChats(new Map(privateChats));\r\n//     } else {\r\n//       let list = [];\r\n//       list.push(payloadData);\r\n//       privateChats.set(payloadData.senderName, list);\r\n//       setPrivateChats(new Map(privateChats));\r\n//     }\r\n//   }*/\r\n\r\n//     const onPrivateMessage = (payload) => {\r\n//       var payloadData = JSON.parse(payload.body);\r\n//       if (privateChats.get(payloadData.senderName)) {\r\n//         privateChats.get(payloadData.senderName).push(payloadData);\r\n//         setPrivateChats(new Map(privateChats));\r\n//       } else {\r\n//         let list = [];\r\n//         list.push(payloadData);\r\n//         privateChats.set(payloadData.senderName, list);\r\n//         setPrivateChats(new Map(privateChats));\r\n//       }\r\n  \r\n//       if (tab !== payloadData.senderName) {\r\n//         let count = unreadMessages.get(payloadData.senderName) || 0;\r\n//         unreadMessages.set(payloadData.senderName, count + 1);\r\n//         setUnreadMessages(new Map(unreadMessages));\r\n//       }\r\n//     }\r\n\r\n//     const handleTabChange = (name) => {\r\n//       setTab(name);\r\n//       if (unreadMessages.get(name)) {\r\n//         unreadMessages.set(name, 0);\r\n//         setUnreadMessages(new Map(unreadMessages));\r\n//       }\r\n//     };\r\n    \r\n\r\n//   const onError = (err) => {\r\n//     console.log(err);\r\n//   }\r\n\r\n//   const handleMessage = (event) => {\r\n//     const { value } = event.target;\r\n//     setUserData({ ...userData, \"message\": value });\r\n//   }\r\n\r\n//   const sendValue = () => {\r\n//     if (stompClient) {\r\n//       var chatMessage = {\r\n//         senderName: userData.username,\r\n//         message: userData.message,\r\n//         status: \"MESSAGE\"\r\n//       };\r\n//       console.log(chatMessage);\r\n//       stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n//       setUserData({ ...userData, \"message\": \"\" });\r\n//     }\r\n//   }\r\n\r\n//   const sendPrivateValue = () => {\r\n//     if (stompClient) {\r\n//       var chatMessage = {\r\n//         senderName: userData.username,\r\n//         receiverName: tab,\r\n//         message: userData.message,\r\n//         status: \"MESSAGE\"\r\n//       };\r\n\r\n//       if (userData.username !== tab) {\r\n//         privateChats.get(tab).push(chatMessage);\r\n//         setPrivateChats(new Map(privateChats));\r\n//       }\r\n//       stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n//       setUserData({ ...userData, \"message\": \"\" });\r\n//     }\r\n//   }\r\n\r\n//   const handleUsername = (event) => {\r\n//     const { value } = event.target;\r\n//     setUserData({ ...userData, \"username\": value });\r\n//   }\r\n\r\n//   const registerUser = () => {\r\n//     connect();\r\n//   }\r\n// /*\r\n//   return (\r\n//     <ChatRoomUI\r\n//       userData={userData}\r\n//       privateChats={privateChats}\r\n//       publicChats={publicChats}\r\n//       tab={tab}\r\n//       setTab={setTab}\r\n//       handleMessage={handleMessage}\r\n//       sendValue={sendValue}\r\n//       sendPrivateValue={sendPrivateValue}\r\n//       handleUsername={handleUsername}\r\n//       registerUser={registerUser}\r\n//     />\r\n//   );*/\r\n\r\n//   return (\r\n//     <ChatRoomUI\r\n//       userData={userData}\r\n//       privateChats={privateChats}\r\n//       publicChats={publicChats}\r\n//       tab={tab}\r\n//       //setTab={setTab}\r\n//       setTab={handleTabChange}\r\n//       handleMessage={handleMessage}\r\n//       sendValue={sendValue}\r\n//       sendPrivateValue={sendPrivateValue}\r\n//       handleUsername={handleUsername}\r\n//       registerUser={registerUser}\r\n//       unreadMessages={unreadMessages}\r\n//       //setUnreadMessages={setUnreadMessages} // Añadir esta línea\r\n//     />\r\n//   );\r\n  \r\n  \r\n// }\r\n\r\n// export default ChatRoom;\r\n/* \r\nimport React, { useEffect, useState } from 'react';\r\nimport { over } from 'stompjs';\r\nimport SockJS from 'sockjs-client';\r\nimport ChatRoomUI from './ChatRoomUI';\r\n\r\nlet stompClient = null;\r\n\r\nconst ChatRoom = () => {\r\n  const [privateChats, setPrivateChats] = useState(new Map());\r\n  const [publicChats, setPublicChats] = useState([]);\r\n  const [tab, setTab] = useState(\"CHATROOM\");\r\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\r\n\r\n  const [userData, setUserData] = useState({\r\n    username: '',\r\n    receivername: '',\r\n    connected: false,\r\n    message: ''\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (userData.connected) {\r\n      connect();\r\n    }\r\n  }, [userData.connected]);\r\n\r\n  const connect = () => {\r\n    let Sock = new SockJS('http://localhost:8080/ws');\r\n    stompClient = over(Sock);\r\n    stompClient.connect({}, onConnected, onError);\r\n  }\r\n\r\n  const onConnected = () => {\r\n    setUserData({ ...userData, connected: true });\r\n    stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n    stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n    stompClient.subscribe('/user/' + userData.username + '/queue/notifications', onNotificationReceived);\r\n    userJoin();\r\n  }\r\n\r\n  const onNotificationReceived = (payload) => {\r\n    var notification = JSON.parse(payload.body);\r\n    alert(notification.message); // Muestra una alerta, puedes personalizar esto para mostrar notificaciones en tu UI\r\n  }\r\n\r\n  const userJoin = () => {\r\n    var chatMessage = {\r\n      senderName: userData.username,\r\n      status: \"JOIN\"\r\n    };\r\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n  }\r\n\r\n  const onMessageReceived = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    switch (payloadData.status) {\r\n      case \"JOIN\":\r\n        if (!privateChats.get(payloadData.senderName)) {\r\n          privateChats.set(payloadData.senderName, []);\r\n          setPrivateChats(new Map(privateChats));\r\n        }\r\n        break;\r\n      case \"MESSAGE\":\r\n        publicChats.push(payloadData);\r\n        setPublicChats([...publicChats]);\r\n        break;\r\n    }\r\n  }\r\n\r\n  const onPrivateMessage = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    if (privateChats.get(payloadData.senderName)) {\r\n      privateChats.get(payloadData.senderName).push(payloadData);\r\n      setPrivateChats(new Map(privateChats));\r\n    } else {\r\n      let list = [];\r\n      list.push(payloadData);\r\n      privateChats.set(payloadData.senderName, list);\r\n      setPrivateChats(new Map(privateChats));\r\n    }\r\n\r\n    if (tab !== payloadData.senderName) {\r\n      let count = unreadMessages.get(payloadData.senderName) || 0;\r\n      unreadMessages.set(payloadData.senderName, count + 1);\r\n      setUnreadMessages(new Map(unreadMessages));\r\n    }\r\n  }\r\n\r\n  const handleTabChange = (name) => {\r\n    setTab(name);\r\n    if (unreadMessages.get(name)) {\r\n      unreadMessages.set(name, 0);\r\n      setUnreadMessages(new Map(unreadMessages));\r\n    }\r\n  };\r\n\r\n  const onError = (err) => {\r\n    console.log(err);\r\n  }\r\n\r\n  const handleMessage = (event) => {\r\n    const { value } = event.target;\r\n    setUserData({ ...userData, message: value });\r\n  }\r\n\r\n  const sendValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n      stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const sendPrivateValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        receiverName: tab,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n\r\n      if (userData.username !== tab) {\r\n        privateChats.get(tab).push(chatMessage);\r\n        setPrivateChats(new Map(privateChats));\r\n      }\r\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const handleUsername = (event) => {\r\n    const { value } = event.target;\r\n    setUserData({ ...userData, username: value });\r\n  }\r\n\r\n  const registerUser = () => {\r\n    setUserData({ ...userData, connected: true });\r\n  }\r\n\r\n  return (\r\n    <ChatRoomUI\r\n      userData={userData}\r\n      privateChats={privateChats}\r\n      publicChats={publicChats}\r\n      tab={tab}\r\n      setTab={handleTabChange}\r\n      handleMessage={handleMessage}\r\n      sendValue={sendValue}\r\n      sendPrivateValue={sendPrivateValue}\r\n      handleUsername={handleUsername}\r\n      registerUser={registerUser}\r\n      unreadMessages={unreadMessages}\r\n    />\r\n  );\r\n}\r\n\r\nexport default ChatRoom;\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\nimport React, { useEffect, useState } from 'react';\r\nimport { over } from 'stompjs';\r\nimport SockJS from 'sockjs-client';\r\nimport ChatRoomUI from './ChatRoomUI';\r\nimport axios from 'axios';\r\n\r\n\r\nlet stompClient = null;\r\n\r\nconst ChatRoom = () => {\r\n  const [privateChats, setPrivateChats] = useState(new Map());\r\n  const [publicChats, setPublicChats] = useState([]);\r\n  const [tab, setTab] = useState(\"CHATROOM\");\r\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\r\n\r\n  const [userData, setUserData] = useState({\r\n    username: '',\r\n    password: '',\r\n    email: '',\r\n    receivername: '',\r\n    connected: false,\r\n    message: ''\r\n  });\r\n\r\n  const [isRegistering, setIsRegistering] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (userData.connected) {\r\n      connect();\r\n    }\r\n  }, [userData.connected]);\r\n\r\n    const connect = () => {\r\n      let Sock = new SockJS('http://localhost:8080/ws');\r\n      stompClient = over(Sock);\r\n      stompClient.connect({username: userData.username}, onConnected, onError);\r\n    }\r\n\r\n  const onConnected = () => {\r\n    setUserData({ ...userData, connected: true });\r\n    stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n    stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n    userJoin();\r\n  }\r\n\r\n  const onNotificationReceived = (payload) => {\r\n    var notification = JSON.parse(payload.body);\r\n    alert(notification.message); // Muestra una alerta, puedes personalizar esto para mostrar notificaciones en tu UI\r\n  }\r\n\r\n  const userJoin = () => {\r\n    var chatMessage = {\r\n      senderName: userData.username,\r\n      status: \"JOIN\"\r\n    };\r\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n  }\r\n\r\n  const onMessageReceived = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    switch (payloadData.status) {\r\n      case \"JOIN\":\r\n        if (!privateChats.get(payloadData.senderName)) {\r\n          privateChats.set(payloadData.senderName, []);\r\n          setPrivateChats(new Map(privateChats));\r\n        }\r\n        break;\r\n      case \"MESSAGE\":\r\n        publicChats.push(payloadData);\r\n        setPublicChats([...publicChats]);\r\n        break;\r\n    }\r\n  }\r\n\r\n  const onPrivateMessage = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    if (privateChats.get(payloadData.senderName)) {\r\n      privateChats.get(payloadData.senderName).push(payloadData);\r\n      setPrivateChats(new Map(privateChats));\r\n    } else {\r\n      let list = [];\r\n      list.push(payloadData);\r\n      privateChats.set(payloadData.senderName, list);\r\n      setPrivateChats(new Map(privateChats));\r\n    }\r\n\r\n    if (tab !== payloadData.senderName) {\r\n      let count = unreadMessages.get(payloadData.senderName) || 0;\r\n      unreadMessages.set(payloadData.senderName, count + 1);\r\n      setUnreadMessages(new Map(unreadMessages));\r\n    }\r\n  }\r\n\r\n  const handleTabChange = (name) => {\r\n    setTab(name);\r\n    if (unreadMessages.get(name)) {\r\n      unreadMessages.set(name, 0);\r\n      setUnreadMessages(new Map(unreadMessages));\r\n    }\r\n  };\r\n\r\n  const onError = (err) => {\r\n    console.log(err);\r\n  }\r\n\r\n  const handleMessage = (event) => {\r\n    const { value } = event.target;\r\n    setUserData({ ...userData, message: value });\r\n  }\r\n\r\n  const sendValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n      stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const sendPrivateValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        receiverName: tab,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n\r\n      if (userData.username !== tab) {\r\n        privateChats.get(tab).push(chatMessage);\r\n        setPrivateChats(new Map(privateChats));\r\n      }\r\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const handleUsername = (event) => {\r\n    const { name, value } = event.target;\r\n    setUserData({ ...userData, [name]: value });\r\n  }\r\n\r\n  const registerUser = async () => {\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/register', {\r\n        username: userData.username,\r\n        password: userData.password,\r\n        email: userData.email\r\n      });\r\n      console.log(response.data);\r\n      setIsRegistering(false);\r\n    } catch (error) {\r\n      console.error('Registration failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  const loginUser = async () => {\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/login', {\r\n        username: userData.username,\r\n        password: userData.password\r\n      });\r\n      console.log(response.data);\r\n      setUserData({ ...userData, connected: true });\r\n    } catch (error) {\r\n      console.error('Login failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  return (\r\n    <ChatRoomUI\r\n      userData={userData}\r\n      privateChats={privateChats}\r\n      publicChats={publicChats}\r\n      tab={tab}\r\n      setTab={setTab}\r\n      handleMessage={handleMessage}\r\n      sendValue={sendValue}\r\n      sendPrivateValue={sendPrivateValue}\r\n      handleUsername={handleUsername}\r\n      registerUser={registerUser}\r\n      loginUser={loginUser}\r\n      unreadMessages={unreadMessages}\r\n      isRegistering={isRegistering}\r\n      setIsRegistering={setIsRegistering}\r\n    />\r\n  );\r\n}\r\n\r\nexport default ChatRoom;\r\n\r\n*/\r\n\r\n/*\r\nimport React, { useEffect, useState } from 'react';\r\nimport { over } from 'stompjs';\r\nimport SockJS from 'sockjs-client';\r\nimport ChatRoomUI from './ChatRoomUI';\r\nimport axios from 'axios';\r\n\r\nlet stompClient = null;\r\n\r\nconst ChatRoom = () => {\r\n  const [privateChats, setPrivateChats] = useState(new Map());\r\n  const [publicChats, setPublicChats] = useState([]);\r\n  const [tab, setTab] = useState(\"CHATROOM\");\r\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\r\n\r\n  const [userData, setUserData] = useState({\r\n    username: '',\r\n    password: '',\r\n    email: '',\r\n    receivername: '',\r\n    connected: false,\r\n    message: ''\r\n  });\r\n\r\n  const [isRegistering, setIsRegistering] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (userData.connected) {\r\n      connect();\r\n    }\r\n  }, [userData.connected]);\r\n\r\n  const connect = () => {\r\n    let Sock = new SockJS('http://localhost:8080/ws');\r\n    stompClient = over(Sock);\r\n    stompClient.connect({username: userData.username}, onConnected, onError);\r\n  }\r\n\r\n  const onConnected = () => {\r\n    setUserData({ ...userData, connected: true });\r\n    stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n    stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n    userJoin();\r\n  }\r\n\r\n  const userJoin = () => {\r\n    var chatMessage = {\r\n      senderName: userData.username,\r\n      status: \"JOIN\"\r\n    };\r\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n  }\r\n\r\n  const onMessageReceived = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    switch (payloadData.status) {\r\n      case \"JOIN\":\r\n        if (!privateChats.get(payloadData.senderName)) {\r\n          privateChats.set(payloadData.senderName, []);\r\n          setPrivateChats(new Map(privateChats));\r\n        }\r\n        break;\r\n      case \"MESSAGE\":\r\n        publicChats.push(payloadData);\r\n        setPublicChats([...publicChats]);\r\n        break;\r\n    }\r\n  }\r\n\r\n  const onPrivateMessage = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    if (privateChats.get(payloadData.senderName)) {\r\n      privateChats.get(payloadData.senderName).push(payloadData);\r\n      setPrivateChats(new Map(privateChats));\r\n    } else {\r\n      let list = [];\r\n      list.push(payloadData);\r\n      privateChats.set(payloadData.senderName, list);\r\n      setPrivateChats(new Map(privateChats));\r\n    }\r\n\r\n    if (tab !== payloadData.senderName) {\r\n      let count = unreadMessages.get(payloadData.senderName) || 0;\r\n      unreadMessages.set(payloadData.senderName, count + 1);\r\n      setUnreadMessages(new Map(unreadMessages));\r\n    }\r\n  }\r\n\r\n  const handleTabChange = (name) => {\r\n    setTab(name);\r\n    if (unreadMessages.get(name)) {\r\n      unreadMessages.set(name, 0);\r\n      setUnreadMessages(new Map(unreadMessages));\r\n    }\r\n  };\r\n\r\n  const onError = (err) => {\r\n    console.log(err);\r\n  }\r\n\r\n  const handleMessage = (event) => {\r\n    const { value } = event.target;\r\n    setUserData({ ...userData, message: value });\r\n  }\r\n\r\n  const sendValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n      stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const sendPrivateValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        receiverName: tab,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n\r\n      if (userData.username !== tab) {\r\n        privateChats.get(tab).push(chatMessage);\r\n        setPrivateChats(new Map(privateChats));\r\n      }\r\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const handleUsername = (event) => {\r\n    const { name, value } = event.target;\r\n    setUserData({ ...userData, [name]: value });\r\n  }\r\n\r\n  const registerUser = async () => {\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/register', {\r\n        username: userData.username,\r\n        password: userData.password,\r\n        email: userData.email\r\n      });\r\n      console.log(response.data);\r\n      setIsRegistering(false);\r\n    } catch (error) {\r\n      console.error('Registration failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  const loginUser = async () => {\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/login', {\r\n        username: userData.username,\r\n        password: userData.password\r\n      });\r\n      console.log(response.data);\r\n      setUserData({ ...userData, connected: true });\r\n    } catch (error) {\r\n      console.error('Login failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  return (\r\n    <ChatRoomUI\r\n      userData={userData}\r\n      privateChats={privateChats}\r\n      publicChats={publicChats}\r\n      tab={tab}\r\n      setTab={handleTabChange}\r\n      handleMessage={handleMessage}\r\n      sendValue={sendValue}\r\n      sendPrivateValue={sendPrivateValue}\r\n      handleUsername={handleUsername}\r\n      registerUser={registerUser}\r\n      loginUser={loginUser}\r\n      unreadMessages={unreadMessages}\r\n      isRegistering={isRegistering}\r\n      setIsRegistering={setIsRegistering}\r\n    />\r\n  );\r\n}\r\n\r\nexport default ChatRoom;*/\r\n/*\r\nimport React, { useEffect, useState } from 'react';\r\nimport { over } from 'stompjs';\r\nimport SockJS from 'sockjs-client';\r\nimport ChatRoomUI from './ChatRoomUI';\r\nimport axios from 'axios';\r\n\r\nlet stompClient = null;\r\n\r\nconst ChatRoom = () => {\r\n  const [privateChats, setPrivateChats] = useState(new Map());\r\n  const [publicChats, setPublicChats] = useState([]);\r\n  const [tab, setTab] = useState(\"CHATROOM\");\r\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\r\n\r\n  const [userData, setUserData] = useState({\r\n    username: '',\r\n    password: '',\r\n    email: '',\r\n    receivername: '',\r\n    connected: false,\r\n    message: ''\r\n  });\r\n\r\n  const [isRegistering, setIsRegistering] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (userData.connected) {\r\n      connect();\r\n    }\r\n  }, [userData.connected]);\r\n\r\n  const connect = () => {\r\n    let Sock = new SockJS('http://localhost:8080/ws');\r\n    stompClient = over(Sock);\r\n    stompClient.connect({username: userData.username}, onConnected, onError);\r\n  }\r\n\r\n  const onConnected = () => {\r\n    setUserData({ ...userData, connected: true });\r\n    stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n    stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n    userJoin();\r\n  }\r\n\r\n  const userJoin = () => {\r\n    var chatMessage = {\r\n      senderName: userData.username,\r\n      status: \"JOIN\"\r\n    };\r\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n  }\r\n\r\n  const onMessageReceived = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    switch (payloadData.status) {\r\n      case \"JOIN\":\r\n        if (!privateChats.get(payloadData.senderName)) {\r\n          privateChats.set(payloadData.senderName, []);\r\n          setPrivateChats(new Map(privateChats));\r\n        }\r\n        break;\r\n      case \"MESSAGE\":\r\n        publicChats.push(payloadData);\r\n        setPublicChats([...publicChats]);\r\n        break;\r\n    }\r\n  }\r\n\r\n  const onPrivateMessage = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    if (privateChats.get(payloadData.senderName)) {\r\n      privateChats.get(payloadData.senderName).push(payloadData);\r\n      setPrivateChats(new Map(privateChats));\r\n    } else {\r\n      let list = [];\r\n      list.push(payloadData);\r\n      privateChats.set(payloadData.senderName, list);\r\n      setPrivateChats(new Map(privateChats));\r\n    }\r\n\r\n    if (tab !== payloadData.senderName) {\r\n      setUnreadMessages(prevUnreadMessages => {\r\n        const newUnreadMessages = new Map(prevUnreadMessages);\r\n        const count = newUnreadMessages.get(payloadData.senderName) || 0;\r\n        newUnreadMessages.set(payloadData.senderName, count + 1);\r\n        return newUnreadMessages;\r\n      });\r\n    }\r\n  }\r\n\r\n  const handleTabChange = (name) => {\r\n    setTab(name);\r\n    setUnreadMessages(prevUnreadMessages => {\r\n      const newUnreadMessages = new Map(prevUnreadMessages);\r\n      newUnreadMessages.delete(name);\r\n      return newUnreadMessages;\r\n    });\r\n  };\r\n\r\n  const onError = (err) => {\r\n    console.log(err);\r\n  }\r\n\r\n  const handleMessage = (event) => {\r\n    const { value } = event.target;\r\n    setUserData({ ...userData, message: value });\r\n  }\r\n\r\n  const sendValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n      stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const sendPrivateValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        receiverName: tab,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n\r\n      if (userData.username !== tab) {\r\n        privateChats.get(tab).push(chatMessage);\r\n        setPrivateChats(new Map(privateChats));\r\n      }\r\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const handleUsername = (event) => {\r\n    const { name, value } = event.target;\r\n    setUserData({ ...userData, [name]: value });\r\n  }\r\n\r\n  const registerUser = async () => {\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/register', {\r\n        username: userData.username,\r\n        password: userData.password,\r\n        email: userData.email\r\n      });\r\n      console.log(response.data);\r\n      setIsRegistering(false);\r\n    } catch (error) {\r\n      console.error('Registration failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  const loginUser = async () => {\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/login', {\r\n        username: userData.username,\r\n        password: userData.password\r\n      });\r\n      console.log(response.data);\r\n      setUserData({ ...userData, connected: true });\r\n    } catch (error) {\r\n      console.error('Login failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  return (\r\n    <ChatRoomUI\r\n      userData={userData}\r\n      privateChats={privateChats}\r\n      publicChats={publicChats}\r\n      tab={tab}\r\n      setTab={handleTabChange}\r\n      handleMessage={handleMessage}\r\n      sendValue={sendValue}\r\n      sendPrivateValue={sendPrivateValue}\r\n      handleUsername={handleUsername}\r\n      registerUser={registerUser}\r\n      loginUser={loginUser}\r\n      unreadMessages={unreadMessages}\r\n      isRegistering={isRegistering}\r\n      setIsRegistering={setIsRegistering}\r\n    />\r\n  );\r\n}\r\n\r\nexport default ChatRoom;\r\n\r\n*/\r\n\r\n\r\n/* \r\nimport React, { useEffect, useState } from 'react';\r\nimport { over } from 'stompjs';\r\nimport SockJS from 'sockjs-client';\r\nimport ChatRoomUI from './ChatRoomUI';\r\nimport axios from 'axios';\r\nimport DOMPurify from 'dompurify';\r\n\r\nlet stompClient = null;\r\n\r\nconst ChatRoom = () => {\r\n  const [privateChats, setPrivateChats] = useState(new Map());\r\n  const [publicChats, setPublicChats] = useState([]);\r\n  const [tab, setTab] = useState(\"CHATROOM\");\r\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\r\n  const [allUsers, setAllUsers] = useState([]);\r\n  const [searchQuery, setSearchQuery] = useState('');\r\n\r\n  const [userData, setUserData] = useState({\r\n    username: '',\r\n    password: '',\r\n    email: '',\r\n    receivername: '',\r\n    connected: false,\r\n    message: '',\r\n    errors: {}\r\n  });\r\n  const [isRegistering, setIsRegistering] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (userData.connected) {\r\n      connect();\r\n    }\r\n  }, [userData.connected]);\r\n\r\n  const connect = () => {\r\n    let Sock = new SockJS('http://localhost:8080/ws');\r\n    stompClient = over(Sock);\r\n    stompClient.connect({username: userData.username}, onConnected, onError);\r\n  }\r\n\r\n  const onConnected = () => {\r\n    setUserData({ ...userData, connected: true });\r\n    stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n    stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n    userJoin();\r\n  }\r\n\r\n  const userJoin = () => {\r\n    var chatMessage = {\r\n      senderName: userData.username,\r\n      status: \"JOIN\"\r\n    };\r\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n  }\r\n\r\n  const onMessageReceived = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    switch (payloadData.status) {\r\n      case \"JOIN\":\r\n        if (!privateChats.get(payloadData.senderName)) {\r\n          privateChats.set(payloadData.senderName, []);\r\n          setPrivateChats(new Map(privateChats));\r\n        }\r\n        break;\r\n      case \"MESSAGE\":\r\n        publicChats.push(payloadData);\r\n        setPublicChats([...publicChats]);\r\n        break;\r\n    }\r\n  }\r\n\r\n  const sanitizeInput = (input) => {\r\n    return DOMPurify.sanitize(input);\r\n  };\r\n\r\n  const onPrivateMessage = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    if (privateChats.get(payloadData.senderName)) {\r\n      privateChats.get(payloadData.senderName).push(payloadData);\r\n      setPrivateChats(new Map(privateChats));\r\n    } else {\r\n      let list = [];\r\n      list.push(payloadData);\r\n      privateChats.set(payloadData.senderName, list);\r\n      setPrivateChats(new Map(privateChats));\r\n    }\r\n\r\n    if (tab !== payloadData.senderName) {\r\n      setUnreadMessages(prevUnreadMessages => {\r\n        const newUnreadMessages = new Map(prevUnreadMessages);\r\n        const count = newUnreadMessages.get(payloadData.senderName) || 0;\r\n        newUnreadMessages.set(payloadData.senderName, count + 1);\r\n        return newUnreadMessages;\r\n      });\r\n    }\r\n  }\r\n\r\n  const handleTabChange = (name) => {\r\n    setTab(name);\r\n    setUnreadMessages(prevUnreadMessages => {\r\n      const newUnreadMessages = new Map(prevUnreadMessages);\r\n      newUnreadMessages.delete(name);\r\n      return newUnreadMessages;\r\n    });\r\n  };\r\n\r\n  const onError = (err) => {\r\n    console.log(err);\r\n  }\r\n\r\n  const handleMessage = (event) => {\r\n    const { value } = event.target;\r\n    setUserData({ ...userData, message: value });\r\n  }\r\n\r\n  const sendValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n      stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  const sendPrivateValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        receiverName: tab,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n\r\n      if (userData.username !== tab) {\r\n        privateChats.get(tab).push(chatMessage);\r\n        setPrivateChats(new Map(privateChats));\r\n      }\r\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  \r\n  const handleUsername = (event) => {\r\n    const { name, value } = event.target;\r\n    \r\n    if (name === \"username\") {\r\n      const filteredValue = value.replace(/[^a-zA-Z0-9\\s]/g, '');\r\n      setUserData({ ...userData, [name]: filteredValue });\r\n    } else {\r\n      setUserData({ ...userData, [name]: value });\r\n      const sanitizedValue = DOMPurify.sanitize(value);\r\n      setUserData({ ...userData, [name]: sanitizedValue });\r\n    }\r\n  };\r\n\r\n\r\n \r\n\r\n  const validateEmail = (email) => {\r\n    const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n    return re.test(String(email).toLowerCase());\r\n  };\r\n\r\n  const validateUsername = (username) => {\r\n    const re = /^[a-zA-Z]+$/;\r\n    return re.test(username);\r\n  };\r\n\r\n  const validateFields = () => {\r\n    const errors = {};\r\n    if (!userData.username || !validateUsername(userData.username)) {\r\n      errors.username = \"El nombre de usuario solo puede contener letras\";\r\n    }\r\n    if (!userData.password) {\r\n      errors.password = \"La contraseña no puede estar vacía\";\r\n    }\r\n    if (!userData.email || !validateEmail(userData.email)) {\r\n      errors.email = \"El email no es válido\";\r\n    }\r\n    return errors;\r\n  };\r\n\r\n  const registerUser = async () => {\r\n    const errors = validateFields();\r\n    if (Object.keys(errors).length > 0) {\r\n      setUserData({ ...userData, errors });\r\n      return;\r\n    }\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/register', {\r\n        username: userData.username,\r\n        password: userData.password,\r\n        email: userData.email\r\n      });\r\n      console.log(response.data);\r\n      setIsRegistering(false);\r\n    } catch (error) {\r\n      console.error('Registration failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  const validateLoginFields = () => {\r\n    const errors = {};\r\n    if (!userData.username) {\r\n      errors.username = \"El nombre de usuario no puede estar vacío\";\r\n    }\r\n    if (!userData.password) {\r\n      errors.password = \"La contraseña no puede estar vacía\";\r\n    }\r\n    return errors;\r\n  };\r\n  \r\n  const loginUser = async () => {\r\n    const errors = validateLoginFields();\r\n    if (Object.keys(errors).length > 0) {\r\n      setUserData({ ...userData, errors });\r\n      return;\r\n    }\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/login', {\r\n        username: userData.username,\r\n        password: userData.password\r\n      });\r\n      console.log(response.data);\r\n      setUserData({ ...userData, connected: true, errors: {} });\r\n    } catch (error) {\r\n      console.error('Login failed:', error.response.data);\r\n      setUserData({ ...userData, errors: { ...errors, login: 'Nombre de usuario o contraseña incorrectos' } });\r\n    }\r\n  };\r\n\r\n  \r\n  return (\r\n    <ChatRoomUI\r\n      userData={userData}\r\n      privateChats={privateChats}\r\n      publicChats={publicChats}\r\n      tab={tab}\r\n      setTab={handleTabChange}\r\n      handleMessage={handleMessage}\r\n      sendValue={sendValue}\r\n      sendPrivateValue={sendPrivateValue}\r\n      handleUsername={handleUsername}\r\n      registerUser={registerUser}\r\n      loginUser={loginUser}\r\n      unreadMessages={unreadMessages}\r\n      isRegistering={isRegistering}\r\n      setIsRegistering={setIsRegistering}\r\n    />\r\n  );\r\n}\r\n\r\nexport default ChatRoom;\r\n\r\n\r\n\r\n\r\n\r\n */\r\n\r\n\r\n\r\n\r\nimport React, { useEffect, useState } from 'react';\r\nimport { over } from 'stompjs';\r\nimport SockJS from 'sockjs-client';\r\nimport ChatRoomUI from './ChatRoomUI';\r\nimport axios from 'axios';\r\nimport DOMPurify from 'dompurify';\r\n\r\nlet stompClient = null;\r\n\r\nconst ChatRoom = () => {\r\n  const [privateChats, setPrivateChats] = useState(new Map());\r\n  const [publicChats, setPublicChats] = useState([]);\r\n  const [tab, setTab] = useState(\"CHATROOM\");\r\n  const [unreadMessages, setUnreadMessages] = useState(new Map());\r\n  const [allUsers, setAllUsers] = useState([]);\r\n  const [searchQuery, setSearchQuery] = useState('');\r\n\r\n  const [userData, setUserData] = useState({\r\n    username: '',\r\n    password: '',\r\n    email: '',\r\n    receivername: '',\r\n    connected: false,\r\n    message: '',\r\n    errors: {}\r\n  });\r\n  const [isRegistering, setIsRegistering] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (userData.connected) {\r\n      connect();\r\n      fetchAllUsers();\r\n      loadChatHistory();\r\n\r\n\r\n    }\r\n  }, [userData.connected]);\r\n\r\n  useEffect(() => {\r\n    if (tab !== \"CHATROOM\" && userData.connected) {\r\n      loadPrivateChatHistory(tab);\r\n    }\r\n  }, [tab]);\r\n\r\n  /*\r\n  const loadPrivateChatHistory = async (receiverName) => {\r\n    try {\r\n      const response = await axios.get(`http://localhost:8080/api/chats/history?senderName=${userData.username}&receiverName=${receiverName}`);\r\n      setPrivateChats(new Map(privateChats.set(receiverName, response.data)));\r\n    } catch (error) {\r\n      console.error('Error loading private chat history:', error);\r\n    }\r\n  };*/\r\n\r\n  /*\r\n  const loadPrivateChatHistory = async (receiverName) => {\r\n    try {\r\n        const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=${receiverName}`);\r\n        const sortedMessages = response.data.sort((a, b) => new Date(a.date) - new Date(b.date));\r\n        setPrivateChats(new Map(privateChats.set(receiverName, sortedMessages)));\r\n    } catch (error) {\r\n        console.error('Error loading private chat history:', error);\r\n    }\r\n  };\r\n  \r\n\r\n\r\n  const connect = () => {\r\n    let Sock = new SockJS('http://localhost:8080/ws');\r\n    stompClient = over(Sock);\r\n    stompClient.connect({username: userData.username}, onConnected, onError);\r\n  }\r\n\r\n  const onConnected = () => {\r\n    setUserData({ ...userData, connected: true });\r\n    stompClient.subscribe('/chatroom/public', onMessageReceived);\r\n    stompClient.subscribe('/user/' + userData.username + '/private', onPrivateMessage);\r\n    userJoin();\r\n    fetchAllUsers();\r\n    loadChatHistory();\r\n  }\r\n\r\n  const userJoin = () => {\r\n    var chatMessage = {\r\n      senderName: userData.username,\r\n      status: \"JOIN\"\r\n    };\r\n    stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n  }\r\n  const fetchAllUsers = async () => {\r\n    try {\r\n      const response = await axios.get('http://localhost:8080/api/users/all');\r\n      setAllUsers(response.data);\r\n    } catch (error) {\r\n      console.error('Failed to fetch users:', error);\r\n    }\r\n  };\r\n\r\n  const sendPrivateValue = () => {\r\n    if (stompClient) {\r\n        var chatMessage = {\r\n            senderName: userData.username,\r\n            receiverName: tab,\r\n            message: userData.message,\r\n            status: \"MESSAGE\"\r\n        };\r\n\r\n        if (userData.username !== tab) {\r\n            let msgs = privateChats.get(tab) || [];\r\n            msgs.push(chatMessage);\r\n            setPrivateChats(new Map(privateChats.set(tab, msgs)));\r\n        }\r\n        stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n        setUserData({ ...userData, message: \"\" });\r\n    }\r\n}\r\n/*\r\nconst sendPrivateValue = () => {\r\n  if (stompClient) {\r\n      var chatMessage = {\r\n          senderName: userData.username,\r\n          receiverName: tab,\r\n          message: userData.message,\r\n          status: \"MESSAGE\"\r\n      };\r\n\r\n      if (userData.username !== tab) {\r\n          let msgs = privateChats.get(tab) || [];\r\n          msgs.push(chatMessage);\r\n          setPrivateChats(new Map(privateChats.set(tab, msgs)));\r\n      }\r\n      stompClient.send(\"/app/private-message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n  }\r\n}*/\r\n\r\n\r\nconst searchUsers = async () => {\r\n    try {\r\n        const response = await axios.get(`http://localhost:8080/api/users/search`, {\r\n            params: { query: searchQuery }\r\n        });\r\n        setAllUsers(response.data);\r\n    } catch (error) {\r\n        console.error('Error searching users:', error);\r\n    }\r\n};\r\n/*\r\n  const loadChatHistory = async () => {\r\n    try {\r\n        const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=ALL`);\r\n        setPublicChats(response.data);\r\n        \r\n    } catch (error) {\r\n        console.error('Error loading chat history:', error);\r\n    }\r\n};*/\r\n/*\r\nconst loadChatHistory = async () => {\r\n  try {\r\n      // Obtener mensajes públicos\r\n      const publicResponse = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=ALL`);\r\n      setPublicChats(publicResponse.data);\r\n\r\n      // Obtener mensajes privados\r\n      const privateResponse = await axios.get(`http://localhost:8080/api/chats/history?senderName=${userData.username}&receiverName=${userData.username}`);\r\n      privateResponse.data.forEach(chat => {\r\n          let messages = privateChats.get(chat.receiverName) || [];\r\n          messages.push(chat);\r\n          setPrivateChats(new Map(privateChats.set(chat.receiverName, messages)));\r\n      });\r\n\r\n  } catch (error) {\r\n      console.error('Error loading chat history:', error);\r\n  }\r\n};*/\r\n\r\nconst loadChatHistory = async () => {\r\n  try {\r\n      const response = await axios.get(`http://localhost:8080/api/chat/history?senderName=${userData.username}&receiverName=ALL`);\r\n      const sortedMessages = response.data.sort((a, b) => new Date(a.date) - new Date(b.date));\r\n      setPublicChats(sortedMessages);\r\n  } catch (error) {\r\n      console.error('Error loading chat history:', error);\r\n  }\r\n};\r\n\r\n// In the useEffect hook\r\nuseEffect(() => {\r\n  if (userData.connected) {\r\n      connect();\r\n      fetchAllUsers();\r\n      loadChatHistory();\r\n  }\r\n}, [userData.connected]);\r\n\r\nuseEffect(() => {\r\n  if (tab !== \"CHATROOM\" && userData.connected) {\r\n      loadPrivateChatHistory(tab);\r\n  }\r\n}, [tab]);\r\n\r\n\r\n\r\n/*\r\n  const onMessageReceived = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    switch (payloadData.status) {\r\n      case \"JOIN\":\r\n        if (!privateChats.get(payloadData.senderName)) {\r\n          privateChats.set(payloadData.senderName, []);\r\n          setPrivateChats(new Map(privateChats));\r\n        }\r\n        break;\r\n      case \"MESSAGE\":\r\n        publicChats.push(payloadData);\r\n        setPublicChats([...publicChats]);\r\n        break;\r\n    }\r\n  }\r\n  */\r\n    const onMessageReceived = (payload) => {\r\n      var payloadData = JSON.parse(payload.body);\r\n      switch (payloadData.status) {\r\n          case \"JOIN\":\r\n              if (!privateChats.get(payloadData.senderName)) {\r\n                  privateChats.set(payloadData.senderName, []);\r\n                  setPrivateChats(new Map(privateChats));\r\n              }\r\n              fetchAllUsers();\r\n              break;\r\n          case \"MESSAGE\":\r\n              publicChats.push(payloadData);\r\n              setPublicChats([...publicChats]);\r\n              break;\r\n          case \"NEW_USER\":\r\n            fetchAllUsers(); // Actualizar la lista de usuarios cuando un nuevo usuario se registra\r\n            break;\r\n          default:\r\n              setAllUsers([...allUsers, payloadData]);\r\n              break;\r\n      }\r\n  }\r\n  \r\n  const sanitizeInput = (input) => {\r\n    return DOMPurify.sanitize(input);\r\n  };\r\n/*\r\n  const onPrivateMessage = (payload) => {\r\n    var payloadData = JSON.parse(payload.body);\r\n    if (privateChats.get(payloadData.senderName)) {\r\n      privateChats.get(payloadData.senderName).push(payloadData);\r\n      setPrivateChats(new Map(privateChats));\r\n    } else {\r\n      let list = [];\r\n      list.push(payloadData);\r\n      privateChats.set(payloadData.senderName, list);\r\n      setPrivateChats(new Map(privateChats));\r\n    }\r\n\r\n    if (tab !== payloadData.senderName) {\r\n      setUnreadMessages(prevUnreadMessages => {\r\n        const newUnreadMessages = new Map(prevUnreadMessages);\r\n        const count = newUnreadMessages.get(payloadData.senderName) || 0;\r\n        newUnreadMessages.set(payloadData.senderName, count + 1);\r\n        return newUnreadMessages;\r\n      });\r\n    }\r\n  }*/\r\n\r\n    /*\r\n    const onPrivateMessage = (payload) => {\r\n      const payloadData = JSON.parse(payload.body);\r\n  \r\n      // Agregar mensaje al chat privado del remitente\r\n      if (privateChats.get(payloadData.senderName)) {\r\n          privateChats.get(payloadData.senderName).push(payloadData);\r\n      } else {\r\n          let list = [];\r\n          list.push(payloadData);\r\n          privateChats.set(payloadData.senderName, list);\r\n      }\r\n      setPrivateChats(new Map(privateChats));\r\n  \r\n      if (tab !== payloadData.senderName) {\r\n          setUnreadMessages(prevUnreadMessages => {\r\n              const newUnreadMessages = new Map(prevUnreadMessages);\r\n              const count = newUnreadMessages.get(payloadData.senderName) || 0;\r\n              newUnreadMessages.set(payloadData.senderName, count + 1);\r\n              return newUnreadMessages;\r\n          });\r\n      }\r\n  };*/\r\n\r\n  const onPrivateMessage = (payload) => {\r\n    const payloadData = JSON.parse(payload.body);\r\n\r\n    // Agregar mensaje al chat privado del remitente\r\n    if (privateChats.get(payloadData.senderName)) {\r\n        privateChats.get(payloadData.senderName).push(payloadData);\r\n    } else {\r\n        let list = [];\r\n        list.push(payloadData);\r\n        privateChats.set(payloadData.senderName, list);\r\n    }\r\n    setPrivateChats(new Map(privateChats));\r\n\r\n    if (tab !== payloadData.senderName) {\r\n        setUnreadMessages(prevUnreadMessages => {\r\n            const newUnreadMessages = new Map(prevUnreadMessages);\r\n            const count = newUnreadMessages.get(payloadData.senderName) || 0;\r\n            newUnreadMessages.set(payloadData.senderName, count + 1);\r\n            return newUnreadMessages;\r\n        });\r\n    }\r\n};\r\n\r\n  \r\n\r\n    const updateUserOnlineStatus = (username, online) => {\r\n      setAllUsers(prevUsers => prevUsers.map(user =>\r\n          user.username === username ? { ...user, online } : user\r\n      ));\r\n  };\r\n  \r\n  const renderUserStatus = (user) => {\r\n    return user.online ? (\r\n        <span style={{ color: 'green' }}>Online</span>\r\n    ) : (\r\n        <span style={{ color: 'red' }}>Offline</span>\r\n    );\r\n};\r\n\r\nconst renderUserList = () => {\r\n  return allUsers.map(user => (\r\n      <div key={user.username} style={{ margin: '10px 0' }}>\r\n          <span>{user.username}</span> {renderUserStatus(user)}\r\n      </div>\r\n  ));\r\n};\r\n  \r\n\r\n  const handleTabChange = (name) => {\r\n    setTab(name);\r\n    setUnreadMessages(prevUnreadMessages => {\r\n      const newUnreadMessages = new Map(prevUnreadMessages);\r\n      newUnreadMessages.delete(name);\r\n      return newUnreadMessages;\r\n    });\r\n  };\r\n  \r\n  const handleSearch = (event) => {\r\n    const query = event.target.value;\r\n    setSearchQuery(query);\r\n    if (query.length > 0) {\r\n      searchUsers(query);\r\n    } else {\r\n      fetchAllUsers();\r\n    }\r\n  };\r\n\r\n\r\n  const onError = (err) => {\r\n    console.log(err);\r\n  }\r\n\r\n  const handleMessage = (event) => {\r\n    const { value } = event.target;\r\n    setUserData({ ...userData, message: value });\r\n  }\r\n\r\n  const sendValue = () => {\r\n    if (stompClient) {\r\n      var chatMessage = {\r\n        senderName: userData.username,\r\n        message: userData.message,\r\n        status: \"MESSAGE\"\r\n      };\r\n      stompClient.send(\"/app/message\", {}, JSON.stringify(chatMessage));\r\n      setUserData({ ...userData, message: \"\" });\r\n    }\r\n  }\r\n\r\n  \r\n\r\n  \r\n  const handleUsername = (event) => {\r\n    const { name, value } = event.target;\r\n    \r\n    if (name === \"username\") {\r\n      const filteredValue = value.replace(/[^a-zA-Z0-9\\s]/g, '');\r\n      setUserData({ ...userData, [name]: filteredValue });\r\n    } else {\r\n      setUserData({ ...userData, [name]: value });\r\n      const sanitizedValue = DOMPurify.sanitize(value);\r\n      setUserData({ ...userData, [name]: sanitizedValue });\r\n    }\r\n  };\r\n\r\n\r\n \r\n\r\n  const validateEmail = (email) => {\r\n    const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n    return re.test(String(email).toLowerCase());\r\n  };\r\n\r\n  const validateUsername = (username) => {\r\n    const re = /^[a-zA-Z]+$/;\r\n    return re.test(username);\r\n  };\r\n\r\n  const validateFields = () => {\r\n    const errors = {};\r\n    if (!userData.username || !validateUsername(userData.username)) {\r\n      errors.username = \"El nombre de usuario solo puede contener letras\";\r\n    }\r\n    if (!userData.password) {\r\n      errors.password = \"La contraseña no puede estar vacía\";\r\n    }\r\n    if (!userData.email || !validateEmail(userData.email)) {\r\n      errors.email = \"El email no es válido\";\r\n    }\r\n    return errors;\r\n  };\r\n\r\n  const registerUser = async () => {\r\n    const errors = validateFields();\r\n    if (Object.keys(errors).length > 0) {\r\n      setUserData({ ...userData, errors });\r\n      return;\r\n    }\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/register', {\r\n        username: userData.username,\r\n        password: userData.password,\r\n        email: userData.email\r\n      });\r\n      console.log(response.data);\r\n      setIsRegistering(false);\r\n    } catch (error) {\r\n      console.error('Registration failed:', error.response.data);\r\n    }\r\n  }\r\n\r\n  const validateLoginFields = () => {\r\n    const errors = {};\r\n    if (!userData.username) {\r\n      errors.username = \"El nombre de usuario no puede estar vacío\";\r\n    }\r\n    if (!userData.password) {\r\n      errors.password = \"La contraseña no puede estar vacía\";\r\n    }\r\n    return errors;\r\n  };\r\n  \r\n  const loginUser = async () => {\r\n    const errors = validateLoginFields();\r\n    if (Object.keys(errors).length > 0) {\r\n      setUserData({ ...userData, errors });\r\n      return;\r\n    }\r\n    try {\r\n      const response = await axios.post('http://localhost:8080/api/auth/login', {\r\n        username: userData.username,\r\n        password: userData.password\r\n      });\r\n      console.log(response.data);\r\n      setUserData({ ...userData, connected: true, errors: {} });\r\n    } catch (error) {\r\n      console.error('Login failed:', error.response.data);\r\n      setUserData({ ...userData, errors: { ...errors, login: 'Nombre de usuario o contraseña incorrectos' } });\r\n    }\r\n  };\r\n\r\n  \r\n  return (\r\n    <ChatRoomUI\r\n      userData={userData}\r\n      privateChats={privateChats}\r\n      publicChats={publicChats}\r\n      tab={tab}\r\n      setTab={handleTabChange}\r\n      handleMessage={handleMessage}\r\n      sendValue={sendValue}\r\n      sendPrivateValue={sendPrivateValue}\r\n      handleUsername={handleUsername}\r\n      registerUser={registerUser}\r\n      loginUser={loginUser}\r\n      unreadMessages={unreadMessages}\r\n      isRegistering={isRegistering}\r\n      setIsRegistering={setIsRegistering}\r\n      allUsers={allUsers}\r\n      searchQuery={searchQuery}\r\n      setSearchQuery={setSearchQuery}\r\n      searchUsers={searchUsers}\r\n      renderUserStatus={searchUsers}\r\n      renderUserList={searchUsers}\r\n\r\n    />\r\n  );\r\n}\r\n\r\nexport default ChatRoom;\r\n\r\n\r\n\r\n\r\n\r\n"]},"metadata":{},"sourceType":"module"}